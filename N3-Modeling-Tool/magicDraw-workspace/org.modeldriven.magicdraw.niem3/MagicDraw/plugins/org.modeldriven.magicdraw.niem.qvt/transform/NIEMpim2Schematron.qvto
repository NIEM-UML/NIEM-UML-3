import NIEMpim2psm;
import NIEMpsm2xsd;
modeltype UML uses 'http://www.nomagic.com/magicdraw/UML/2.4.1';
modeltype ECORE  uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype CHANGELOG uses 'http://reference.niem.gov/niem/resource/mpd/changelog/1.0/';
modeltype SCHEMATRON uses 'http://purl.oclc.org/dsdl/schematron';
modeltype XML uses 'http://www.eclipse.org/emf/2003/XMLType';
//modeltype OCL uses 'http://www.eclipse.org/ocl/1.1.0/OCL/Expressions';
modeltype OCL uses 'http://www.eclipse.org/ocl/1.1.0/UML';


transformation NIEMpim2Schematron(
	inout niemUml:UML,
	inout blackboxAdapter:ECORE
	,out sch:SCHEMATRON
	)
	extends NIEMpim2psm(UML)
	;
	main() {
		log('schematronTest');
		blackboxHook:=blackboxAdapter.objectsOfType(ECORE::EPackage)->asSequence()->first();
		// look for information model packages which have classifier constraints
		var topRoot:UML::Model:=niemUml.rootObjects()
			->select(m|m.oclIsKindOf(UML::Model))
			.oclAsType(UML::Model)->asSequence()->first();

		topRoot.oclAsType(UML::Model).initializeProfileGlobals();

		var allPimMpds:Set(UML::Component)=topRoot.allSubobjectsOfType(UML::Component).oclAsType(UML::Component)
			->select(c|
				c.IsStereotypeApplied(prompdStereotype)
				and c.isEditable()
				and not(c.isInPSM())
				)->asSet();
		// find the business rule suites, for each get package imports
		allPimMpds.clientDependency
			->select(d|d.IsStereotypeApplied(NIEMModelPackageDescriptionFileStereotype) and d.oclAsType(UML::Usage).isPurposeBusinessRule())
			.supplier->select(p|p.oclIsKindOf(UML::Package)).oclAsType(UML::Package).map InformationModelSchematron();
				
		// gather all pim schemas, then use to create schematrons
		/*
		var allPimSchemas:Set(UML::Package)=allPimMpds.gatherAllPimSchemas()->asSet();
		log('schematron allPimSchemas '+allPimSchemas->size().repr());
		allPimSchemas->select(s|s.ownedType->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier).ownedRule->notEmpty())
			.map InformationModelSchematron();
			*/
	}
query UML::NamedElement::isInPSM():Boolean{
	if(self.oclIsKindOf(UML::Package) and (self.name='PSM'))
		then {return true;}
		else{
			if(self.owner.oclIsUndefined())then {return false;} else{return self.owner.oclAsType(UML::NamedElement).isInPSM();}endif;
		}endif;
}	
query UML::Usage::isPurposeBusinessRule():Boolean{
	return self.GetStereotypeApplication(NIEMModelPackageDescriptionFileStereotype).oclAsType(Stdlib::Element).getFileTypePurposeCode()=purposeBusinessRules;
}
	
property currentSchemaType:SCHEMATRON::SchemaType=null;
	
mapping 	UML::Package::InformationModelSchematron():SCHEMATRON::DocumentRoot@sch
{	
	log('schematron InformationModelSchematron '+self.qualifiedName);
	schema+=self.map InformationModelSchema(result);
}
mapping 	UML::Package::InformationModelSchema(inout documentRoot:SCHEMATRON::DocumentRoot):SCHEMATRON::SchemaType@sch
{
	//	log('schematron InformationModelSchema '+self.qualifiedName);
	currentSchemaType:=result;
	// should pattern be a schema, rule a classifier selection, assert a constraint?
	id:=self.name.toNCName();
	queryBinding:='xslt2';
	// NIEM infrastructure namespaces
	var infrastructureSchemas:Set(String)=Set{
		appinfoNamespace,
//		appinfo2SchemaNamespace, // not in NIEM3
		LocalTerminologyTargetNamespace,ConformanceTargetNamespace,
		structuresSchemaNamespace,proxySchemaNamespace,"http://www.w3.org/1999/XSL/Transform",
		"http://www.w3.org/2005/xpath-functions",schemaForSchemaNamespace};
		
	infrastructureSchemas.map PrefixForNamespace(result);
	
	// set prefix to be used for Schema namespace
//	ns+=self.map PrefixForSchemaNamespace(result);

	// prefixes for referenced schemas
	// gather all references to schema components via typedElements, generalizations, dependencies;
	// collect the schemas for those schema components in packageRefs
	var packageRefs:Set(UML::Package)=Set{};
	/*
			var allPimSchemas:Set(UML::Package)=allPimMpds.gatherAllPimSchemas()->asSet();
		log('schematron allPimSchemas '+allPimSchemas->size().repr());
		allPimSchemas->select(s|s.ownedType->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier).ownedRule->notEmpty())
			.map InformationModelSchematron();
	
	self.allSubobjectsOfKind(UML::Property).oclAsType(UML::Property)
		->select(p|not(p.type.oclIsUndefined())).type->forEach(type){packageRefs+=type.getNearestNIEMSchemaPackage();};
	self.allSubobjectsOfKind(UML::Classifier).oclAsType(UML::Classifier).general
		->forEach(type){packageRefs+=type.getNearestNIEMSchemaPackage();};
	self.allSubobjectsOfKind(UML::DirectedRelationship).oclAsType(UML::DirectedRelationship).target
		->forEach(type){packageRefs+=type.getNearestNIEMSchemaPackage();};
*/
	self.packageImport.importedPackage.allSubobjectsOfKind(UML::Property).oclAsType(UML::Property)
		->select(p|not(p.type.oclIsUndefined())).type->forEach(type){packageRefs+=type.getNearestNIEMSchemaPackage();};
	self.packageImport.importedPackage.allSubobjectsOfKind(UML::Classifier).oclAsType(UML::Classifier).general
		->forEach(type){packageRefs+=type.getNearestNIEMSchemaPackage();};
		/* this brings in reference models, do not think we need this
	self.packageImport.importedPackage.allSubobjectsOfKind(UML::DirectedRelationship).oclAsType(UML::DirectedRelationship).target
		->forEach(type){packageRefs+=type.getNearestNIEMSchemaPackage();};
		*/
	// filter out those schemas which are unresolved or are this schema
	packageRefs:= packageRefs->select(p|not(p.oclIsUndefined() or (p=self)));
	// map each of those referenced Schemas to an XSDImport
	ns+=packageRefs.map PrefixForSchemaNamespace(result);
	// determine schema locations
//	var schemaLocations:String='';
	packageRefs->forEach(packageRef){
		var pimStereotypeInstance:Stdlib::Element=packageRef.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
		// set schema targetNamespace from <<Namespace>>
		var targetNamespace:String=pimStereotypeInstance.getSchemaTargetNamespace();
		//var relativePath:String=packageRef.qualifiedName.replace('::','/');
//	relativePathName:=schemaPackage.toRelativePathName(schemaPackage.getNearestPackage().getNearesProfileApplication(niemXsdProfile),result);
	var relativePath:String=packageRef.toRelativePathName(packageRef.getNearesProfileApplication(niemXsdProfile),self);
		
		if(not(relativePath.endsWith('.xsd')))then{relativePath:=relativePath+'.xsd';}else{}endif;
		// alternatively schemaLocation could be in an mpdFile relativePathName
		self.supplierDependency->select(d|d.IsStereotypeApplied(NIEMModelPackageDescriptionFileStereotype))
			->forEach(mpdFile){
				var pimmpd:Stdlib::Element=mpdFile.getStereotypeApplication(NIEMModelPackageDescriptionFileStereotype).oclAsType(Stdlib::Element);
				var explicitRelativePathName:String =pimmpd.getFileTypeRelativePathName();
				if(not(explicitRelativePathName.oclIsUndefined()) and (explicitRelativePathName<>''))then{
					relativePath:=explicitRelativePathName;
				}endif;
				
			};
		// adjust 
//		relativePath:='../../'+relativePath;	
		relativePath:='../'+relativePath;	
//		if(schemaLocations='')then {schemaLocations:=targetNamespace+' '+relativePath;}else{schemaLocations:=' '+targetNamespace+' '+relativePath;}endif;
		// the schema location does not seem to do anything , 
		// use <xsl:import-schema namespace="http://domain.gov/myDomain/" schema-location="../XMLschemas/niem/domains/hix/0.1/hix-o/hix-o.xsd" />    
		result.addImportSchema(targetNamespace,relativePath);
		log('schemaLocations '+targetNamespace+', '+relativePath);
		documentRoot.addXSISchemaLocation(targetNamespace,relativePath);
//		documentRoot.xSISchemaLocation+=
	};
	title+=self.ownedComment.map Title();
	/*
	if(self.ownedType->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier).ownedRule->notEmpty())then{
		pattern+=self.map InformationModelPattern();
	}endif;	
	*/
	pattern+=packageRefs
		->select(p|p.ownedType->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier).ownedRule->notEmpty())
		.map InformationModelPattern();
}
mapping 	UML::Comment::Title():SCHEMATRON::TitleType@sch
{
	result.setTitleText(self.body);
}
mapping 	UML::Package::PrefixForSchemaNamespace(inout schema:SCHEMATRON::SchemaType):SCHEMATRON::NsType@sch
{
	var pimStereotypeInstance:Stdlib::Element=self.GetStereotypeApplication(NIEMSchemaStereotype).oclAsType(Stdlib::Element);
	// set schema targetNamespace from <<Namespace>>
	var targetNamespace:String=pimStereotypeInstance.getSchemaTargetNamespace();
	var defaultPrefix:String=pimStereotypeInstance.getSchemaDefaultPrefix();
	var isKnownNamespace:Boolean=false;
	uri:=targetNamespace;
	prefixToNamespace->forEach(entry){
		if(entry.namespace=targetNamespace)then{
			prefix:=entry.prefix;
			isKnownNamespace:=true;
			break;
		}endif;
	};
	if(not(isKnownNamespace))then{
		if(not(defaultPrefix.oclIsUndefined())and(defaultPrefix<>''))then{
			prefix:=defaultPrefix;
		}else{
			prefix:='tns';
		}endif;
	}endif;
		log('schematron PrefixForSchemaNamespace '+result.prefix+' = '+result.uri+', '+pimStereotypeInstance.repr()+', '+defaultPrefix);
	
}
mapping 	String::PrefixForNamespace(inout schema:SCHEMATRON::SchemaType):SCHEMATRON::NsType@sch
{
	// use standard prefixes
	uri:=self;
	prefixToNamespace->forEach(entry){
		if(entry.namespace=self)then{
			prefix:=entry.prefix;
			break;
		}endif;
	};
		log('schematron PrefixForNamespace '+result.prefix+' = '+result.uri);
		schema.ns+=result;
}
mapping 	UML::Package::InformationModelPattern():SCHEMATRON::PatternType@sch
{
	// should pattern be a schema, rule a classifier selection, assert a constraint?
		log('schematron InformationModelPattern '+self.qualifiedName);
	id:=self.name.toNCName()+'BusinessRules';
	title+=self.ownedComment.map Title();
	rule+=self.ownedType
		->select(t|t.oclIsKindOf(UML::Classifier)).oclAsType(UML::Classifier)
		->select(c|c.ownedRule->notEmpty()).map ClassifierRule();
}
mapping 	UML::Classifier::ClassifierRule():SCHEMATRON::RuleType@sch
{
	// should pattern be a schema, rule a classifier selection, assert a constraint?
	// context: a containment property whose type is this Classifier, or any of its base types
	/*
	context:='';
	self._typedElementOfType
		->select(p|p.oclIsKindOf(UML::Property)).oclAsType(UML::Property)
		->select(p|p.isNavigable() and (p.aggregation!=UML::AggregationKind::none))
		->forEach(p){
		if(result.context!='')then {context:=result.context+'|';}endif;
		context:=result.context+p.QName();
	};
	*/
		log('schematron ClassifierRule '+self.qualifiedName);
		role:=self.qualifiedName;
		//fpi:='test fpi';// does nothing
	context:='element(*,'+self.QName()+')';
	_assert+=self.ownedRule.map ConstraintAssert();
}
mapping 	UML::Constraint::ConstraintAssert():SCHEMATRON::AssertType@sch
{
	// should pattern be a schema, rule a classifier selection, assert a constraint?
	// get error message as text
	var stereotypeInstance:UML::InstanceSpecification=self.getStereotypeApplication().oclAsType(UML::InstanceSpecification);
	role:=stereotypeInstance.getAnyValue('abbreviation').oclAsType(String);
	flag:=stereotypeInstance.getAnyValue('severity').oclAsType(String);
	// set schema targetNamespace from <<Namespace>>
	result.setAssertText(stereotypeInstance.getAnyValue('errorMessage').oclAsType(String));
	/*
	self.ownedComment->forEach(comment){
		result.setAssertText(comment.body);
	};
	*/
	var expression:OCL::OCLExpression=self.Expression();
	if(not(expression.oclIsUndefined()))then{
		test:=expression.expressionToTest();
	}endif;	
		log('schematron ConstraintAssert '+expression.repr()+', '+result.test+', '+expression.oclAsType(ecore::EObject).eClass().name
		+', '+expression.oclAsType(ecore::EObject).eClass().ePackage.nsURI);
}
///////////////////
abstract helper OCL::OCLExpression::expressionToTest():String;// abstract
abstract helper OCL::CallExp::expressionToTest():String;// abstract
abstract helper OCL::FeatureCallExp::expressionToTest():String;// abstract
abstract helper OCL::AssociationClassCallExp::expressionToTest():String;
abstract helper OCL::NavigationCallExp::expressionToTest():String;// abstract
abstract helper OCL::LoopExp::expressionToTest():String;// abstract
abstract helper OCL::MessageExp::expressionToTest():String;// no counterpart
abstract helper OCL::StateExp::expressionToTest():String;// no counterpart
abstract helper OCL::LiteralExp::expressionToTest():String;// abstract
abstract helper OCL::PrimitiveLiteralExp::expressionToTest():String;// abstract
abstract helper OCL::NumericLiteralExp::expressionToTest():String;// abstract
abstract helper OCL::TupleLiteralExp::expressionToTest():String;// no counterpart
abstract helper OCL::CollectionLiteralPart::expressionToTest():String;// abstract
abstract helper OCL::IterateExp::expressionToTest():String;// no counterpart

helper OCL::CollectionItem::expressionToTest():String{return self.item().expressionToTest();}
helper OCL::CollectionRange::expressionToTest():String{return self.first().expressionToTest()+' to '+self.last().expressionToTest();}
helper OCL::CollectionLiteralExp::expressionToTest():String{return
	'('+self.part()
		->forEach(collectionLiteralPart){
			if(self.part()->indexOf(collectionLiteralPart)=1)then '' else ',' endif
			+collectionLiteralPart.expressionToTest();
		}+')'
;}
helper OCL::OCLExpression::booleanExpression():String{
	return 'xs:boolean('+self.expressionToTest()+')';
}
helper OCL::IteratorExp::expressionToTest():String{
	switch{
			case(self.expressionName()='select'){
				return	'for $'+self.iterator()->at(1).variableName()+' in '+self.source().expressionToTest()
					+' return if('+self.body().booleanExpression()+')then $'+self.iterator()->at(1).variableName() 
					+' else ()';
				/*
[4]    	ForExpr 	   ::=    	SimpleForClause "return" ExprSingle
[5]    	SimpleForClause 	   ::=    	"for" "$" VarName "in" ExprSingle ("," "$" VarName "in" ExprSingle)*				
				*/
			};
			case(self.expressionName()='reject'){
				return	'for $'+self.iterator()->at(1).variableName()+' in '+self.source().expressionToTest()
					+' return if('+self.body().booleanExpression()+')then () else $'
					+self.iterator()->at(1).variableName(); 
			};
			// TODO: if set, then should be unique
			case(self.expressionName()='collect'){
				return	'for $'+self.iterator()->at(1).variableName()+' in '+self.source().expressionToTest()
					+' return '+self.body().expressionToTest(); 
			};
			case(self.expressionName()='collectNested'){
				return	'for $'+self.iterator()->at(1).variableName()+' in '+self.source().expressionToTest()
					+' return '+self.body().expressionToTest(); 
			};
			
			case(self.expressionName()='forAll'){
				return	'every $'+self.iterator()->at(1).variableName()+' in '+self.source().expressionToTest()
					+' satisfies '+self.body().booleanExpression(); 
			};
			case(self.expressionName()='exists'){
				return	'some $'+self.iterator()->at(1).variableName()+' in '+self.source().expressionToTest()
					+' satisfies '+self.body().booleanExpression(); 
			};
			case(self.expressionName()='isUnique'){
				return	'fn:count(for $'+self.iterator()->at(1).variableName()+' in '+self.source().expressionToTest()
					+' return '+self.body().expressionToTest()
					+') eq fn:count(fn:distinct-values(for $'
					+self.iterator()->at(1).variableName()+' in '+self.source().expressionToTest()
					+' return '+self.body().expressionToTest()+'))'; 
			};
			case(self.expressionName()='any'){
				return	'(for $'+self.iterator()->at(1).variableName()+' in '+self.source().expressionToTest()
					+' return if('+self.body().booleanExpression()
					+') then $'+self.iterator()->at(1).variableName()
					+' else ())[1]'; 
			};
			case(self.expressionName()='one'){
				return	'fn:count(for $'+self.iterator()->at(1).variableName()+' in '+self.source().expressionToTest()
					+' return if('+self.body().booleanExpression()+')then $'+self.iterator()->at(1).variableName() 
					+' else ()) eq 1';
			};
			case(
				(self.expressionName()='closure')// no counterpart
				or(self.expressionName()='sortedBy')// no direct counterpart in xpath; sort at xlst/xquery level
				){
				
				return	' '+self.expressionName()+'_UnsupportedOperation ';
			};
			/*
			("some" | "every") "$" VarName "in" ExprSingle ("," "$" VarName "in" ExprSingle)* "satisfies" ExprSingle
			*/
			else{
			//self.iterator()->at(1);
//				'fn:'+self.referredOperation().name;
			};
		};return '';}
helper OCL::PropertyCallExp::expressionToTest():String{
	log('PropertyCallExp '+self.source().repr()+', '+ self.referredProperty().name);
	switch{
			case(self.referredProperty().isReference()){
//				return	self.source().expressionToTest()+'/fn:id(@s:ref)';
				return	self.source().expressionToTest()+'/'+self.referredProperty().QName()+'/fn:id(@s:ref)';
			};
			else{
				return	self.source().expressionToTest()+'/'+self.referredProperty().QName();
				
			};
		};
		return '';
}			

helper OCL::OperationCallExp::xpathOperationName():String{
		switch{
			case(self.referredOperation().name='toString'){
				return	'fn:string';
			};
			case(self.referredOperation().name='toUpperCase'){
				return	'fn:upper-case';
			};
			case(self.referredOperation().name='toLowerCase'){
				return	'fn:lower-case';
			};
			case(self.referredOperation().name='toInteger'){
				return	'xs:integer';
			};
			case(self.referredOperation().name='toBoolean'){
				return	'xs:boolean';
			};
			case(self.referredOperation().name='toReal'){
				return	'xs:double';
			};
			case(self.referredOperation().name='size'){
				return	'fn:count';
			};
			
			case(self.referredOperation().name='isEmpty'){
				return	'fn:empty';
			};
			case(self.referredOperation().name='notEmpty'){
				return	'fn:exists';
			};
			case(self.referredOperation().name='asSet'){
				return	'fn:distinct-values';
			};
			case(self.referredOperation().name='asOrderedSet'){
				return	'fn:distinct-values';
			};
			
			case(self.referredOperation().name='+'){
				return	'fn:concat';
			};
			///////////////////////////////QVT
			// TODO: following is string operation, above is collection operation
			case(self.referredOperation().name='size'){
				return	'fn:string-length';
			};
			case(self.referredOperation().name='length'){
				return	'fn:string-length';
			};
			case(self.referredOperation().name='toLower'){
				return	'fn:lower-case';
			};
			case(self.referredOperation().name='toUpper'){
				return	'fn:upper-case';
			};
			case(self.referredOperation().name='trim'){
				return	'fn:normalize-space';
			};
			case(self.referredOperation().name='normalizeSpace'){
				return	'fn:normalize-space';
			};
							
			
			else{
				return	'fn:'+self.referredOperation().name;
			};
		};
		return '';
	}
helper OCL::OperationCallExp::xpath2ArgOperationName():String{
		switch{
			///////////////////////////////QVT
			case(self.referredOperation().name='substringBefore'){
				return	'fn:substring-before';
			};
			case(self.referredOperation().name='substringAfter'){
				return	'fn:substring-after';
			};
			case(self.referredOperation().name='endsWith'){
				return	'fn:ends-with';
			};
			case(self.referredOperation().name='startsWith'){
				return	'fn:starts-with';
			};
			case(self.referredOperation().name='match'){
				return	'fn:matches';
			};
			else{
				return	'fn:'+self.referredOperation().name;
			};
		};
		return '';
		}
helper OCL::OperationCallExp::xpathInfixOperationName():String{
		switch{
			// these depend on operands, = might be eq,=, or is
			// TODO
			case(self.referredOperation().name='='){
				return	'eq';
			};
			case(self.referredOperation().name='equals'){
				return	'eq';
			};
			case(self.referredOperation().name='<>'){
				return	'ne';
			};
			case(self.referredOperation().name='<='){
				return	'le';
			};
			case(self.referredOperation().name='>='){
				return	'ge';
			};
			case(self.referredOperation().name='<'){
				return	'lt';
			};
			case(self.referredOperation().name='>'){
				return	'gt';
			};
			case(self.referredOperation().name='/'){
				return	'div';
			};
			case(self.referredOperation().name='div'){
				return	'idiv';
			};
			case(self.referredOperation().name='union'){
				return	'|';
			};
			case(self.referredOperation().name='including'){
				return	'|';
			};
			case(self.referredOperation().name='excluding'){
				return	'except';
			};
			case(self.referredOperation().name='intersection'){
				return	'intersect';
			};
			case(self.referredOperation().name='range'){
				return	'to';
			};
			else{
				return	self.referredOperation().name
			};
		};
		return '';
		}
 
helper OCL::OperationCallExp::expressionToTest():String{
	log('OperationCallExp '+self.source().repr()+', '+ self.argument()->size().repr()+', '+self.referredOperation().name);
	switch{
			case((self.argument()->size()=1)and(
					(self.referredOperation().name='and') 
					or (self.referredOperation().name='or')
					or ((self.referredOperation().name='+') and not(self.source().getExpressionType().isString()))
					or (self.referredOperation().name='-')
					or (self.referredOperation().name='*')
					or (self.referredOperation().name='=')
					or (self.referredOperation().name='equals')
					or (self.referredOperation().name='<>')
					or (self.referredOperation().name='<=')
					or (self.referredOperation().name='>=')
					or (self.referredOperation().name='<')
					or (self.referredOperation().name='>')
					or (self.referredOperation().name='mod')
					or (self.referredOperation().name='/')
					or (self.referredOperation().name='div')
					or (self.referredOperation().name='union')
					or (self.referredOperation().name='including')
					or (self.referredOperation().name='excluding')
					or (self.referredOperation().name='intersection')
					///QVT
					or (self.referredOperation().name='range')
					
				)){
				//'('+self.argument()->at(1).expressionToTest()+') '+self.xpathInfixOperationName()+' ('+self.argument()->at(2).expressionToTest()+')';
				return	self.source().expressionToTest()+' '+self.xpathInfixOperationName()+' '+self.argument()->at(1).expressionToTest();
			};
			case((self.argument()->size()=1)and(
					(self.referredOperation().name='max') 
					or (self.referredOperation().name='min')
					or (self.referredOperation().name='+')
				)){
//				self.xpathOperationName()+'(('+self.argument()->at(1).expressionToTest()+'),('+self.argument()->at(2).expressionToTest()+'))';
				return	self.xpathOperationName()+'('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+')';
			};
			case((self.argument()->size()=0)and(
					(self.referredOperation().name='-') 
				)){
//				self.referredOperation().name+'('+self.argument()->at(1).expressionToTest()+')';
				return	self.referredOperation().name+'('+self.source().expressionToTest()+')';
			};
			case(
				(self.referredOperation().name='not')
				or(self.referredOperation().name='abs')
				or(self.referredOperation().name='floor')
				or(self.referredOperation().name='round')
				or(self.referredOperation().name='toString')
				or(self.referredOperation().name='toInteger')
				or(self.referredOperation().name='toReal')
				or(self.referredOperation().name='toBoolean')
				or(self.referredOperation().name='toUpperCase')
				or(self.referredOperation().name='toLowerCase')
				or(self.referredOperation().name='size')
				or(self.referredOperation().name='max')
				or(self.referredOperation().name='min')
				or(self.referredOperation().name='sum')
				or(self.referredOperation().name='isEmpty')
				or(self.referredOperation().name='notEmpty')
				or(self.referredOperation().name='asSet')
				or(self.referredOperation().name='asOrderedSet')
				or(self.referredOperation().name='reverse')
				// QVT
				//or(self.referredOperation().name='size') // TODO: conflict with collection size
				or(self.referredOperation().name='length')
				or(self.referredOperation().name='toLower')
				or(self.referredOperation().name='toUpper')
				or(self.referredOperation().name='trim')
				or(self.referredOperation().name='normalizeSpace')
				){
//				self.xpathOperationName()+'('+self.argument()->at(1).expressionToTest()+')';
				return	self.xpathOperationName()+'('+self.source().expressionToTest()+')';
			};
			case((self.argument()->size()=1)and(
				(self.referredOperation().name='substringBefore')
				or(self.referredOperation().name='substringAfter')
				or(self.referredOperation().name='endsWith')
				or(self.referredOperation().name='startsWith')
				or(self.referredOperation().name='match')
				
				)){
				return	self.xpath2ArgOperationName()+'('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+')';
			};
			case(self.referredOperation().name='xor'){
//				'(('+self.argument()->at(1).expressionToTest()+') or ('+self.argument()->at(2).expressionToTest()
//				+'))and fn:not(('+self.argument()->at(1).expressionToTest()+') eq ('+self.argument()->at(2).expressionToTest()+'))'
				return	'(('+self.source().booleanExpression()+') or ('+self.argument()->at(1).booleanExpression()
				+'))and fn:not(('+self.source().booleanExpression()+') eq ('+self.argument()->at(1).booleanExpression()+'))'
				;
			};
			case(self.referredOperation().name='implies'){
//				'fn:not('+self.argument()->at(1).expressionToTest()+') or (('+self.argument()->at(1).expressionToTest()+') and ('+self.argument()->at(2).expressionToTest()+'))';
				return	'fn:not('+self.source().booleanExpression()+') or (('+self.source().booleanExpression()+') and ('+self.argument()->at(1).booleanExpression()+'))';
			};
			case(self.referredOperation().name='substring'){
//				'fn:substring('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+',1+('
//					 +self.argument()->at(3).expressionToTest()+')-('+self.argument()->at(2).expressionToTest()+'))';
				return	'fn:substring('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+',1+('
					 +self.argument()->at(2).expressionToTest()+')-('+self.argument()->at(1).expressionToTest()+'))';
			};
			// TODO: possible conflict with collection operation
			case((self.referredOperation().name='indexOf') and (self.argument()->at(1).getExpressionType().isString())){
//				'if(fn:contains('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()
//					+')then (1+fn:string-length(fn:substring-before('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()
//					+')) else 0';
				return	'if(fn:contains('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()
					+')then (1+fn:string-length(fn:substring-before('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()
					+')) else 0';
			};
			
			case(self.referredOperation().name='find'){
				return	'if(fn:contains('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()
					+')then (1+fn:string-length(fn:substring-before('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()
					+')) else 0';
			};
			case(self.referredOperation().name='equalsIgnoreCase'){
//				'fn:upper-case('+self.argument()->at(1).expressionToTest()+') eq fn:upper-case('+self.argument()->at(2).expressionToTest()+')';
				return	'fn:upper-case('+self.source().expressionToTest()+') eq fn:upper-case('+self.argument()->at(1).expressionToTest()+')';
			};
			case((self.referredOperation().name='at') and (self.argument()->at(1).getExpressionType().isString())){
//				'fn:substring('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+',1)';
				return	'fn:substring('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+',1)';
			};
			case(self.referredOperation().name='count'){
//				'fn:count(fn:index-of('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+'))';
				return	'fn:count(fn:index-of('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+'))';
			};
			case(self.referredOperation().name='includes'){
//				'fn:count(fn:index-of('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+')) gt 0';
				return	'fn:count(fn:index-of('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+')) gt 0';
			};
			case(self.referredOperation().name='excludes'){
//				'fn:count(fn:index-of('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+')) eq 0';
				return	'fn:count(fn:index-of('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+')) eq 0';
			};
			case(self.referredOperation().name='excludesAll'){
//				'fn:count(('+self.argument()->at(1).expressionToTest()+') intersect ('+self.argument()->at(2).expressionToTest()+')) eq 0';
				return	'fn:count(('+self.source().expressionToTest()+') intersect ('+self.argument()->at(1).expressionToTest()+')) eq 0';
			};
			case(self.referredOperation().name='includesAll'){
//				'fn:count(('+self.argument()->at(1).expressionToTest()+') intersect ('+self.argument()->at(2).expressionToTest()
//				+')) eq fn:count('+self.argument()->at(2).expressionToTest()+')';
				return	'fn:count(('+self.source().expressionToTest()+') intersect ('+self.argument()->at(1).expressionToTest()
				+')) eq fn:count('+self.argument()->at(1).expressionToTest()+')';
			};
			case(self.referredOperation().name='symmetricDifference'){
//				'(('+self.argument()->at(1).expressionToTest()+') | ('+self.argument()->at(2).expressionToTest()
//				+')) except (('+self.argument()->at(1).expressionToTest()+') intersect ('+self.argument()->at(2).expressionToTest()+'))';
				return	'(('+self.source().expressionToTest()+') | ('+self.argument()->at(1).expressionToTest()
				+')) except (('+self.source().expressionToTest()+') intersect ('+self.argument()->at(1).expressionToTest()+'))';
			};
			case(self.referredOperation().name='prepend'){
//				'('+self.argument()->at(2).expressionToTest()+'),('+self.argument()->at(1).expressionToTest()+')';
				return	'('+self.argument()->at(1).expressionToTest()+'),('+self.source().expressionToTest()+')';
			};
			case(self.referredOperation().name='insertAt'){
//				'fn:insert-before('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+','+self.argument()->at(3).expressionToTest()+')';
				return	'fn:insert-before('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+')';
			};
			case(self.referredOperation().name='subOrderedSet'){
//				'fn:subsequence('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+',1+('+self.argument()->at(3).expressionToTest()+')-('+self.argument()->at(2).expressionToTest()+'))';
				return	'fn:subsequence('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+',1+('+self.argument()->at(2).expressionToTest()+')-('+self.argument()->at(1).expressionToTest()+'))';
			};
			case(self.referredOperation().name='at'){
//				'fn:subsequence('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+',1)';
				//'fn:subsequence('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+',1)';
				return	self.source().expressionToTest()+'['+self.argument()->at(1).expressionToTest()+']';
			};
			case(self.referredOperation().name='get'){
//				'fn:subsequence('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+',1)';
				//'fn:subsequence('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+',1)';
				return	self.source().expressionToTest()+'['+self.argument()->at(1).expressionToTest()+']';
			};
			case(self.referredOperation().name='remove'){
				return	self.source().expressionToTest()+'['+self.argument()->at(1).expressionToTest()+']';
			};
			// collection operation; there is a string operation of same name
			case(self.referredOperation().name='indexOf'){
//				'fn:subsequence(fn:index-of('+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+'),1,1)';
//				'fn:subsequence('+self.source().expressionToTest()+',fn:index-of('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+'),1)';
				return	'fn:index-of('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+')';
			};
			case(self.referredOperation().name='replace'){
				return	'fn:replace('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+')';
			};
			case(self.referredOperation().name='first'){
//				'fn:subsequence('+self.argument()->at(1).expressionToTest()+',1,1)';
				return	self.source().expressionToTest()+'[fn:first()]';
			};
			case(self.referredOperation().name='last'){
//				'fn:subsequence('+self.argument()->at(1).expressionToTest()+',fn:count('+self.argument()->at(1).expressionToTest()+'),1)';
				return	self.source().expressionToTest()+'[fn:last()]';
			};
			
			case(self.referredOperation().name='asSequence'){
				// no-op
//				self.argument()->at(1).expressionToTest();
				return	self.source().expressionToTest();
			};
			case(self.referredOperation().name='asBag'){
				// no-op
//				self.argument()->at(1).expressionToTest();
				return	self.source().expressionToTest();
			};
			case(self.referredOperation().name='flatten'){
				// no-op, collections are always flattened
				return	self.source().expressionToTest();
			};
			case(self.referredOperation().name='characters'){
				return	'for $codepoint  in fn:string-to-codepoints('+self.source().expressionToTest()
				+') return fn:codepoints-to-string($codepoint)';
			};
			case(self.referredOperation().name='oclIsUndefined'){
				return	'fn:empty('+self.source().expressionToTest()+')';
			};
			case(self.referredOperation().name='oclIsInvalid'){
				return	'fn:empty('+self.source().expressionToTest()+')';
			};
			case(self.referredOperation().name='oclAsType'){
				// TODO: could be attribute here and anywhere element used
				return	self.source().expressionToTest()+' treat as element(*,'+self.argument()->at(1).expressionToTest()+')';
			};
			case(self.referredOperation().name='oclIsTypeOf'){
				// can not determine exactly if it is type?
				return	self.source().expressionToTest()+' instance of element(*,'+self.argument()->at(1).expressionToTest()+')';
			};
			case(self.referredOperation().name='oclIsKindOf'){
				return	self.source().expressionToTest()+' instance of element(*,'+self.argument()->at(1).expressionToTest()+')';
			};
			case(self.referredOperation().name='isInstanceOfType'){
				return	self.source().expressionToTest()+' instance of element(*,'+self.argument()->at(1).expressionToTest()+')';
			};
			
			case(self.referredOperation().name='matchBoolean'){
				return	self.source().expressionToTest()+' castable as xs:boolean';
			};
			case(self.referredOperation().name='matchInteger'){
				return	self.source().expressionToTest()+' castable as xs:integer';
			};
			case(self.referredOperation().name='matchFloat'){
				return	self.source().expressionToTest()+' castable as xs:float';
			};
			case(self.referredOperation().name='matchIdentifier'){
				return	self.source().expressionToTest()+' castable as xs:NCName';
			};
			case(self.referredOperation().name='asBoolean'){
				return	self.source().expressionToTest()+' cast as xs:boolean';
			};
			case(self.referredOperation().name='asInteger'){
				return	self.source().expressionToTest()+' cast as xs:integer';
			};
			case(self.referredOperation().name='asFloat'){
				return	self.source().expressionToTest()+' cast as xs:float';
			};
			case(self.referredOperation().name='firstToUpper'){
				return	'fn:concat(fn:upper-case(fn:substring('
					+self.source().expressionToTest()+',1,1)),fn:substring('
					+self.source().expressionToTest()+',2))';
			};
			case(self.referredOperation().name='lastToUpper'){
				return	'fn:concat(fn:substring('
					+self.source().expressionToTest()+',1,fn:string-length('+self.source().expressionToTest()
					+')-1),fn:upper-case(fn:substring('
					+self.source().expressionToTest()+',fn:string-length('+self.source().expressionToTest()+'),1)))';
			};
			case(self.referredOperation().name='isQuoted'){
				return	'fn:starts-with('
					+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()
					+') and fn:ends-with('
					+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()
					+')';
			};
			case(self.referredOperation().name='quotify'){
				return	'fn:concat('+self.argument()->at(1).expressionToTest()
					+','+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()
					+')';
			};
			case(self.referredOperation().name='unquotify'){
				return	'for $q in '+self.argument()->at(1).expressionToTest()
				+' return for $qlength in fn:string-length($q) return for $s in '
				+self.source().expressionToTest()
				+' return for $length in fn:string-length($s)'
				+' return fn:substring($s,if(fn:starts-with($s,$q))then $qlength else 1,'
				+'$length - (if(fn:ends-with($s,$q)) then $qlength else 0)'
				+' - (if(fn:starts-with($s,$q)) then $qlength else 0))';
			};
			case((self.referredOperation().name='add')and(self.argument()->size()=1)){
				return	'('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+')';
			};
			case(self.referredOperation().name='add'){
				return	'fn:insert-before('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+','+self.argument()->at(2).expressionToTest()+')';
			};
			case(self.referredOperation().name='addAll'){
				return	'('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+')';
			};
			case(self.referredOperation().name='append'){
				return	'('+self.source().expressionToTest()+','+self.argument()->at(1).expressionToTest()+')';
			};
			case(self.referredOperation().name='joinfields'){
				return	'fn:concat('+self.argument()->at(2).expressionToTest()
					+',fn:string-join('+self.source().expressionToTest()
					+','+self.argument()->at(1).expressionToTest()
					+'),'+self.argument()->at(3).expressionToTest()+')';
			};
			case(self.referredOperation().name='_localId'){
				return	'('+self.source().expressionToTest()+')/fn:position()';
			};
			case(self.referredOperation().name='_globalId'){
				return	'('+self.source().expressionToTest()+')/@id';
			};
			case(self.referredOperation().name='subobjects'){
				return	'('+self.source().expressionToTest()+')/*';
			};
			case(self.referredOperation().name='contents'){
				return	'('+self.source().expressionToTest()+')/*';
			};
			case(self.referredOperation().name='allSubobjects'){
				return	'('+self.source().expressionToTest()+')//*';
			};
			case(self.referredOperation().name='clone'){
				return	self.source().expressionToTest();
			};
			case(self.referredOperation().name='deepclone'){
				return	self.source().expressionToTest();
			};
			case(self.referredOperation().name='subobjectsOfType'){
				return	self.source().expressionToTest()+'/*[instance of element(*,'+self.argument()->at(1).expressionToTest()+')]';
			};
			case(self.referredOperation().name='allSubobjectsOfType'){
				return	self.source().expressionToTest()+'//*[instance of element(*,'+self.argument()->at(1).expressionToTest()+')]';
			};
			case(self.referredOperation().name='subobjectsOfKind'){
				return	self.source().expressionToTest()+'/*[instance of element(*,'+self.argument()->at(1).expressionToTest()+')]';
			};
			case(self.referredOperation().name='allSubobjectsOfKind'){
				return	self.source().expressionToTest()+'//*[instance of element(*,'+self.argument()->at(1).expressionToTest()+')]';
			};
			case(self.referredOperation().name='objects'){
				return	'//*';
			};
			case(self.referredOperation().name='elements'){
				return	'//*';
			};
			case(self.referredOperation().name='objectsOfType'){
				return	'//*[instance of element(*,'+self.argument()->at(1).expressionToTest()+')]';
			};
			case(self.referredOperation().name='elementsOfType'){
				return	'//*[instance of element(*,'+self.argument()->at(1).expressionToTest()+')]';
			};
			case(self.referredOperation().name='rootObjects'){
				return	'/*';
			};
			case(self.referredOperation().name='copy'){
				return	'//*';
			};
			case(self.referredOperation().name='createEmptyModel'){
				return	'()';
			};
			case(self.referredOperation().name='removeElement'){
				return	'//* except '+self.argument()->at(1).expressionToTest();
			};
			// MOF
			case(self.referredOperation().name='container'){
				return	self.source().expressionToTest()+'/..';
			};
			case(self.referredOperation().name='clear'){
				return	'()';
			};
			case(self.referredOperation().name='delete'){
				return	'()';
			};
			// remove may have integer or object parameter
			case((self.referredOperation().name='remove')and(self.argument()->at(1).getExpressionType().isInteger())){
				return	self.source().expressionToTest()+' except '+self.source().expressionToTest()+'['+self.argument()->at(1).expressionToTest()+']';
			};
			case(self.referredOperation().name='remove'){
				return	self.source().expressionToTest()+' except '+self.argument()->at(1).expressionToTest();
			};
			case(
				(self.expressionName()='product')// this results in a tuple, not expressible in xpath
				or(self.expressionName()='oclIsNew')// this has no counterpart in xpath
				or(self.expressionName()='oclIsInState')// this has no counterpart in xpath
				or(self.expressionName()='oclType')// not directly accessible via xpath
				or(self.expressionName()='hasReturned')// message operation, no xpath counterpart
				or(self.expressionName()='result')// message operation, no xpath counterpart
				or(self.expressionName()='isSignalSent')// message operation, no xpath counterpart
				or(self.expressionName()='isOperationCall')// message operation, no xpath counterpart
				/////////////////QVT
				or(self.expressionName()='format')//  no xpath counterpart
				or(self.expressionName()='startStrCounter')//  no xpath counterpart
				or(self.expressionName()='getStrCounter')//  no xpath counterpart
				or(self.expressionName()='incrStrCounter')//  no xpath counterpart
				or(self.expressionName()='restartAllStrCounter')//  no xpath counterpart
				or(self.expressionName()='addSuffixNumber')//  no xpath counterpart
				or(self.expressionName()='rfind')//  no xpath counterpart
				or(self.expressionName()='metaClassName')//  no xpath counterpart
				or(self.expressionName()='markedAs')//  no xpath counterpart
				or(self.expressionName()='markValue')//  no xpath counterpart
				or(self.expressionName()='stereotypedBy')//  no xpath counterpart
				or(self.expressionName()='stereotypedStrictlyBy')//  no xpath counterpart
				or(self.expressionName()='asTransformation')//  no xpath counterpart
				///////////////MOF
				or(self.expressionName()='metaclass')//  no xpath counterpart
				or(self.expressionName()='getMetaClass')//  no xpath counterpart
				or(self.expressionName()='get')//  no xpath counterpart.  parameter is Property, a meta-property; but we can not get meta-class and have no access to the type definition from xpath
				or(self.expressionName()='set')//  no xpath counterpart
				or(self.expressionName()='isSet')//  no xpath counterpart
				or(self.expressionName()='unset')//  no xpath counterpart
				or(self.expressionName()='invoke')//  no xpath counterpart
				or(self.expressionName()='createElement')//  no xpath counterpart
				or(self.expressionName()='createLink')//  no xpath counterpart
				or(self.expressionName()='linksOfType')//  no xpath counterpart
				or(self.expressionName()='linkedElements')//  no xpath counterpart
				or(self.expressionName()='linkExists')//  no xpath counterpart
				){
				
				return	' '+self.expressionName()+'_UnsupportedOperation ';
			};
			case(self.referredOperation().name='oclLocale'){
				return	'fn:default-collation()';
			};
			/////////////////////////////////////QVT
			/*
*/			
			else{
				return	self.referredOperation().name+'('+self.source().expressionToTest()+')';// TODO: fill in parameters
			};
		};
		return '';
}
helper OCL::LetExp::expressionToTest():String{return
	'some $'+self.variable().variableName()+' in '+self.variable().initExpression().expressionToTest()+' satisfies '+self._in().booleanExpression();}
helper OCL::IfExp::expressionToTest():String{return 'if('+self.condition().expressionToTest()+')then '+self.thenExpression().expressionToTest()+' else '+self.elseExpression().expressionToTest();}
helper OCL::VariableExp::expressionToTest():String{
	var varName:String='$'+self.referredVariable().variableName();
	if(varName='$self')then return '.' endif;
	return varName;
}
helper OCL::TypeExp::expressionToTest():String{return self.referredType().QName();}
helper OCL::TypeExp::referredType():UML::Classifier{return self.referredType.oclAsType(UML::Classifier);}
helper OCL::BooleanLiteralExp::expressionToTest():String{return if(self.booleanSymbol)then 'fn:true()' else 'fn:false()' endif;}
helper OCL::StringLiteralExp::expressionToTest():String{return '"'+self.stringSymbol.replace('"','""')+'"';}
helper OCL::RealLiteralExp::expressionToTest():String{return self.realSymbol.repr();}
helper OCL::IntegerLiteralExp::expressionToTest():String{return self.integerSymbol.repr();}
helper OCL::UnlimitedNaturalLiteralExp::expressionToTest():String{return self.integerSymbol.repr();}
helper OCL::NullLiteralExp::expressionToTest():String{return 'xs:untypedAtomic(\'\')';}
helper OCL::InvalidLiteralExp::expressionToTest():String{return 'xs:untypedAtomic(\'\')';}
helper OCL::EnumLiteralExp::expressionToTest():String{return '"'+self.referredEnumLiteral.enumLiteralName()+'"';}




query OCL::LoopExp::body(): OCL::OCLExpression=self.body.oclAsType(OCL::OCLExpression);
query OCL::LoopExp::iterator(): Sequence(OCL::Variable)=self.iterator.oclAsType(OCL::Variable);
query OCL::CollectionLiteralExp::part(): Sequence(OCL::CollectionLiteralPart)=self.part.oclAsType(OCL::CollectionLiteralPart);
query OCL::CollectionItem::item(): OCL::OCLExpression=self.item.oclAsType(OCL::OCLExpression);
query OCL::CollectionRange::last(): OCL::OCLExpression=self.last.oclAsType(OCL::OCLExpression);
query OCL::CollectionRange::first(): OCL::OCLExpression=self.first.oclAsType(OCL::OCLExpression);
query OCL::VariableExp::referredVariable(): OCL::Variable=self.referredVariable.oclAsType(OCL::Variable);
query OCL::IfExp::elseExpression(): OCL::OCLExpression=self.elseExpression.oclAsType(OCL::OCLExpression);
query OCL::IfExp::thenExpression(): OCL::OCLExpression=self.thenExpression.oclAsType(OCL::OCLExpression);
query OCL::IfExp::condition(): OCL::OCLExpression=self.condition.oclAsType(OCL::OCLExpression);
query OCL::LetExp::_in(): OCL::OCLExpression=self._in.oclAsType(OCL::OCLExpression);
query OCL::Variable::initExpression(): OCL::OCLExpression=self.initExpression.oclAsType(OCL::OCLExpression);
query OCL::LetExp::variable():OCL::Variable=self.variable.oclAsType(OCL::Variable);
query OCL::OperationCallExp::argument():Sequence(OCL::OCLExpression)=self.argument.oclAsType(OCL::OCLExpression);
query OCL::OperationCallExp::referredOperation():UML::Operation=self.referredOperation.oclAsType(UML::Operation);
query OCL::CallExp::source(): OCL::OCLExpression=self.source.oclAsType(OCL::OCLExpression);
query OCL::OCLExpression::getExpressionType():UML::Type=self.oclAsType(UML::TypedElement).type;
query OCL::OCLExpression::expressionName():String=self.oclAsType(UML::TypedElement).name;
query UML::Property::isReference():Boolean=self.aggregation=UML::AggregationKind::none;
query OCL::PropertyCallExp::referredProperty():UML::Property=self.referredProperty.oclAsType(UML::Property);
query UML::Type::isInteger():Boolean=self.name.equalsIgnoreCase('integer');
query UML::Type::isString():Boolean=self.name.equalsIgnoreCase('string');
//query OCL::Variable::getVariableName():String=self.oclAsType(UML::TypedElement).name;
//query ecore::EObject::operationName():String=self.oclAsType(UML::Operation).name;
query ecore::EObject::enumLiteralName():String=self.oclAsType(UML::EnumerationLiteral).name;
query OCL::Variable::variableName():String=self.oclAsType(UML::TypedElement).name;
abstract query UML::NamedElement::QName():String;
query UML::Classifier::QName():String=self.getNearestPackage().getPrefix()+':'+self.toNiemName();
query UML::Property::QName():String=self.getResolvedProperty().getNearestPackage().getPrefix()+':'+self.getResolvedProperty().toNiemName();
query UML::Package::getPrefix():String=self.map PrefixForSchemaNamespace(currentSchemaType).prefix;
/////////////////TODO via bloackbox
helper SCHEMATRON::AssertType::setAssertText(in message:String){
	var annotation:ECORE::EAnnotation=new ECORE::EAnnotation('setAssertText');
	annotation._references+=self.oclAsType(ecore::EObject);
	"message".setAnnotationDetail(annotation,message);
	blackboxHook.eAnnotations+=annotation;
	return;
}	
helper SCHEMATRON::TitleType::setTitleText(in message:String){
	var annotation:ECORE::EAnnotation=new ECORE::EAnnotation('setTitleText');
	annotation._references+=self.oclAsType(ecore::EObject);
	"message".setAnnotationDetail(annotation,message);
	blackboxHook.eAnnotations+=annotation;
	return;
}	
helper SCHEMATRON::DocumentRoot::addXSISchemaLocation(in targetNamespace:String,in relativeLocation:String){
	var annotation:ECORE::EAnnotation=new ECORE::EAnnotation('addXSISchemaLocation');
	annotation._references+=self.oclAsType(ecore::EObject);
	"targetNamespace".setAnnotationDetail(annotation,targetNamespace);
	"relativeLocation".setAnnotationDetail(annotation,relativeLocation);
	blackboxHook.eAnnotations+=annotation;
	return;
}	
helper SCHEMATRON::SchemaType::addImportSchema(in targetNamespace:String,in relativeLocation:String){
	var annotation:ECORE::EAnnotation=new ECORE::EAnnotation('addImportSchema');
	annotation._references+=self.oclAsType(ecore::EObject);
	"targetNamespace".setAnnotationDetail(annotation,targetNamespace);
	"relativeLocation".setAnnotationDetail(annotation,relativeLocation);
	blackboxHook.eAnnotations+=annotation;
	return;
}	
helper UML::Constraint::Expression():OCL::OCLExpression{
//	self.oclAsType(OCL::OCLExpression);
	var annotation:ECORE::EAnnotation=new ECORE::EAnnotation('Expression');
	annotation._references+=self.oclAsType(ecore::EObject);
	blackboxHook.eAnnotations+=annotation;
	return annotation._references->select(r|r<>self).oclAsType(OCL::OCLExpression)->asSequence()->first();

}
			

	

	
/////////////////////platform-specific abstract bindings
