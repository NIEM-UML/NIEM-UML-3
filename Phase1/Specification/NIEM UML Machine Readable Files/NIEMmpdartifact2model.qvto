import NIEMplatformBinding;
//modeltype UML uses 'http://www.omg.org/spec/UML/20110701';
// platform variants for UML
//modeltype UML uses 'http://www.eclipse.org/uml2/4.0.0/UML';
modeltype UML uses 'http://www.nomagic.com/magicdraw/UML/2.4.1';
modeltype XSD  uses 'http://www.eclipse.org/xsd/2002/XSD';

transformation NIEMmpdartifact2model(inout pimUml:UML);
main() {
	NIEMmpd2pim_run();
}	
	
helper NIEMmpd2pim_run() {
		
		mpdRootPackage:=
			pimUml.rootObjects()
			->select(r|r.oclIsKindOf(UML::Model)).oclAsType(UML::Model)
			->asSequence()->first();
		// initialize profiles based on content of the skeletal base model	
		mpdRootPackage.oclAsType(UML::Model).initializeProfileGlobals();
		// 	examine catalog and get all referenced schemas
		gatherCatalogedSchemas(mpdRootPackage);
		
		// now fully expand schema content
		expandSchemaContent:=true;
		var schemaPackages:Set(UML::Package)=
			mpdRootPackage.allSubobjectsOfType(UML::Package).oclAsType(UML::Package)
			->select(p|p.isEditable() and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
			->asSet();
		log('expandSchemaContent from '+mpdRootPackage.qualifiedName+', schema count='+schemaPackages->size().repr());
		// need to sort in order to reduce chance of QVT stack overflow
		var sortedSchemaPackages:OrderedSet(UML::Package)=schemaPackages->sortedBy(p|p.getSchemaSortName());
		
		sortedSchemaPackages.expandSchemaContent();
		// schemaPackages may have changed during expandSchemaContent
		schemaPackages:=
			mpdRootPackage.allSubobjectsOfType(UML::Package).oclAsType(UML::Package)
			->select(p|p.isEditable() and (p.IsStereotypeApplied(NIEMSchemaStereotype) or p.IsStereotypeApplied(NIEMInformationModelStereotype)))
			->asSet();
	// weed out property holders

		log('propertyHolder adjust');
		schemaPackages.ownedType
			->select(t|t.IsStereotypeApplied(NIEMPropertyHolderStereotype) or t.IsStereotypeApplied(NIEMInformationModelStereotype))
			.oclAsType(UML::Class).adjustPropertyHolders();
		
		log('remove propertyHolder temporary realizations');
		schemaPackages.ownedType
			->select(t|t.IsStereotypeApplied(NIEMPropertyHolderStereotype))
			.oclAsType(UML::Class).adjustPropertyHolderRealizations();
		return;
	}
///////////////////
property expandSchemaContent:Boolean=true;
//property expandComplexContent:Boolean=true;
query UML::Package::getSchemaSortName():String{
	var sortName:String=self.name;
	var purposeCode:String=self.GetStereotypeApplication(NIEMInformationModelStereotype).oclAsType(Stdlib::Element).getInformationModelDefaultPurpose();
	
	if(purposeCode='subset')then{
		sortName:='a'+sortName;
	}else{
		sortName:='b'+sortName;
	}endif;
	return sortName;
}	
/*
helper XSD::XSDComplexTypeDefinition::expandComplexContent(){
		if(not(self.content.oclIsUndefined()))then{
			var umlType:UML::NamedElement=self.resolveSchemaContentReference();
			if(not(umlType.oclIsUndefined()) and (umlType.oclIsKindOf(UML::Class)))then{
				self.content.oclAsType(XSD::XSDParticle)->forEach(particle){
					particle.content.ParticleContent(umlType.oclAsType(UML::Class),particle);
				};
			}endif;
		}endif;
}
*/
helper UML::Package::expandSchemaContent(){
	var schema:XSD::XSDSchema=self.invresolveone(XSD::XSDSchema).oclAsType(XSD::XSDSchema);
	log('expandSchemaContent '+schema.targetNamespace+', '+self.qualifiedName);
	schema.contents.mapAbstractXSDSchemaContent(self);
	log('expandSchemaContent complete for '+schema.targetNamespace+', '+self.qualifiedName);
	return ;	
}
query XSD::XSDSchemaContent::isSchemaContentSimple():Boolean{
	if(not(self.oclIsKindOf(XSD::XSDComplexTypeDefinition)))then {return true;}endif;
	var base:XSD::XSDTypeDefinition=self.oclAsType(XSD::XSDComplexTypeDefinition).baseTypeDefinition;
	if(base.oclIsUndefined() or base.oclIsKindOf(XSD::XSDSimpleTypeDefinition))then{return true;}endif;
	return false;
}	

helper UML::Class::adjustPropertyHolders(){
	var propertyHolder:UML::Class=self;
	var allProperties:Set(UML::Property)=self.ownedAttribute->asSet();
	var sourceHoldingProperties:Set(UML::Property)=
        allProperties
        ->select(p|
        	p.isSubsetCluster() 
        	or (p.type.oclIsUndefined())
        	or p.getTargetDirectedRelationships()
        		->select(r|
        			r.oclIsKindOf(UML::Realization) 
        			and (r.oclAsType(UML::Realization).isAnotherSchema())
	        	)->notEmpty()
	        or (p.getTargetDirectedRelationships()	
        		->select(r|r.oclIsKindOf(UML::Realization)) 
	        	->size()
	        	<>1
	        	)
	        )
        ->asSet();
		propertyHolder.ownedAttribute:=sourceHoldingProperties;
		propertyHolder.name:='Namespace'+if(self.name.startsWith('element'))then 'Element' else 'Attribute' endif+'PropertyHolder';        
	// split out the subsetsProperty clusters to another property holder; cluster by top level
	// for each, create a separate property holder based on property head name
	// for remote heads, add inheritance to the referenced head container
	// also need to change name-based surrogate match
	
	var sourceSubsettingProperties:Set(UML::Property)=
		sourceHoldingProperties->select(p|
        	p.isSubsetCluster() 
        	or (p.type.oclIsUndefined())
        	);
	var sourcePropertyHeads:Set(UML::Property)=sourceSubsettingProperties
		->select(p|p.isSubstitutionGroupHead())
		->union(sourceSubsettingProperties.getSourceSubsetsExternalPropertyHead()->asSet());
	sourcePropertyHeads->forEach(head){
			head.makeTargetSubsetPropertyHolder(sourceSubsettingProperties,self.getNearestPackage());
		};
		// remove unnecessary realizations and properties
		log('adjustPropertyHolders removing extra realizations and properties');
	allProperties->forEach(p){
		p.getTargetDirectedRelationships()
		->select(r|r.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization)
        		->select(r|
        			(r.isSubstitutionGroupAffiliation()
        			or not(r.isAnotherSchema())
        			)and p.owner.oclIsUndefined()
        			)
        		->forEach(removed){
        			removed.client:=Set{};
        			removed.supplier:=Set{};
        			removed.removeElement();
        		};
        		
        if(p.owner.oclIsUndefined())then{
        		p.removeElement();
        	}endif;		
	};
	return ;	
}

helper UML::Class::adjustPropertyHolderRealizations(){
	self.ownedAttribute.getTargetDirectedRelationships()
		->select(r|r.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization)
        		->select(r|
        			r.isSubstitutionGroupAffiliation()
	       			or not(r.isAnotherSchema())
        			)
        		->forEach(removed){
        			removed.client:=Set{};
        			removed.supplier:=Set{};
        			removed.removeElement();
        			//pimUml.removeElement(removed);
        		};
	return ;	
}

query UML::Property::getSourceSubsetsExternalPropertyHead():Set(UML::Property){
	var affiliation:UML::Property=self.getSubstitutionGroupAffiliation();
	if(affiliation.oclIsUndefined() or (affiliation.getNearestPackage()=self.getNearestPackage()))then{return Set{};}endif;
	return Set{affiliation};
}	

query UML::Realization::isAnotherSchema():Boolean{
	var clientSchema:UML::Package=self.client.getNearestPackage()->asSequence()->first();
	var supplierSchema:UML::Package=self.supplier.getNearestPackage()->asSequence()->first();
	return clientSchema<>supplierSchema;
	}

query UML::Property::isSubsetCluster():Boolean=
	not(self.getSubstitutionGroupAffiliation().oclIsUndefined())
	or self.getSubstitutionGroupAffiliationInverse()->notEmpty();
query UML::Property::isSubstitutionGroupHead():Boolean=
	self.getSubstitutionGroupAffiliation().oclIsUndefined()
	and (self.getSubstitutionGroupAffiliationInverse()->notEmpty() or (self.type.oclIsUndefined()));
query UML::Dependency::isSubstitutionGroupAffiliation():Boolean=
	self.oclIsKindOf(UML::Realization) 
			and (self.oclAsType(UML::Realization).name=substitutionGroupAffiliationTag);
query UML::Property::getSubstitutionGroupAffiliation():UML::Property=
	self.clientDependency
		->select(r|r.isSubstitutionGroupAffiliation()).supplier
		->select(c|c.oclIsKindOf(UML::Property) )
		.oclAsType(UML::Property)
		->asSequence()->first();
query UML::Property::getSubstitutionGroupAffiliationInverse():Set(UML::Property)=
	self.getTargetDirectedRelationships()
		->select(r|r.oclIsKindOf(UML::Realization)).oclAsType(UML::Realization)
		->select(r|r.isSubstitutionGroupAffiliation()).client
		->select(c|c.oclIsKindOf(UML::Property))
		.oclAsType(UML::Property)
		->asSet();

helper UML::Property::makeTargetSubsetPropertyHolder(
		sourceSubsettingProperties:Set(UML::Property),
			inout schemaPackage:UML::Package
			){
			// self is head of a substitutionGroup, 
			// 		or a Property in a different namespace which is subsetted by a Property in schemaPackage
			// schemaPackage is package for the created <<PropertyHolder>>
	log('makeTargetSubsetPropertyHolder for '+self.qualifiedName);
	var headProperty:UML::Property=self; 
	// make a new <<PropertyHolder>> and add to schemaPackage
	var propertyHolderName:=self.name+'PropertyHolder';  
	var propertyHolder:UML::Class=schemaPackage.ownedType
		->select(t|t.oclIsKindOf(UML::Class) and (t.name=propertyHolderName)).oclAsType(UML::Class)
		->asSequence()->first(); 
	if(propertyHolder.oclIsUndefined())then{
		propertyHolder:=new UML::Class@pimUml(); 
		schemaPackage.packagedElement+=propertyHolder;
		propertyHolder.ApplyStereotype(NIEMPropertyHolderStereotype);
		propertyHolder.name:=propertyHolderName;  
		
	}endif;
		
		if(self.getNearestPackage()=schemaPackage)then{
			// move the head property into new <<PropertyHolder>>
			propertyHolder.ownedAttribute+=headProperty;
			if(headProperty.type.oclIsUndefined())then{
			headProperty.isDerivedUnion:=true;
			headProperty.isDerived:=true;
			headProperty.isReadOnly:=true;
			}endif;
		}else{
			// generalization required:  from new <<PropertyHolder>> to <<PropertyHolder>> of headProperty
			// unless generalization already exists
			// note that this generalization may need to change if headProperty is later moved to another <<PropertyHolder>>
			if(propertyHolder.generalization->select(g|g.general=headProperty.owner)->isEmpty())then{
				var generalization:UML::Generalization=new UML::Generalization@pimUml(); 
				generalization.specific:=propertyHolder;
				generalization.general:=headProperty.owner.oclAsType(UML::Classifier);
			}endif;
		}endif;	
		// add any properties which subsets self to the new <<PropertyHolder>>
        propertyHolder.ownedAttribute+=sourceSubsettingProperties->select(p|p.subsetsSource(self));
		// if any of the properties in new <<PropertyHolder>> are subset by a Property in foreign namespace,
		// make sure the generalization for that is now correct
		propertyHolder.ownedAttribute->forEach(propertyHolderProperty){
			propertyHolderProperty._propertyOfSubsettedProperty->forEach(propertySubset){
				if(schemaPackage<>propertySubset.getNearestPackage())then{
					var subsettedClassifier:UML::Classifier=propertySubset.classifier;
					if(not(subsettedClassifier.name.startsWith('Namespace')) and (subsettedClassifier<>propertyHolder))then{
						// change its generalization to be the new <<PropertyHolder>>;
						// but watch for generalization loops
						/*
						subsettedClassifier.generalization->forEach(g){
							g.general:=propertyHolder;
						}	;
						*/
						var isGeneralizationLoop:Boolean=not(propertyHolder.generalization->select(g|g.general=subsettedClassifier)->isEmpty());
						if(not(isGeneralizationLoop) and subsettedClassifier.generalization->select(g|g.general=propertyHolder)->isEmpty())then{
							var generalization:UML::Generalization=new UML::Generalization@pimUml(); 
							generalization.specific:=subsettedClassifier;
							generalization.general:=propertyHolder;
						}endif;
											
					}endif;
				}endif;
			};
		};
	return;     
}
query UML::Property::subsetsSource(subsettedProperty:UML::Property):Boolean{
	if(self=subsettedProperty)then {return false;}endif;
	var affiliation:UML::Property=self.getSubstitutionGroupAffiliation();
	if(affiliation.oclIsUndefined())then{return false;}endif;
	if(affiliation=subsettedProperty)then{return true;}endif;
	// do not include if crossing namespaces
	if(affiliation.getNearestPackage()<>self.getNearestPackage())then{return false;}endif;
	return affiliation.subsetsSource(subsettedProperty);
	}
	/*
query UML::Property::subsetsSourceInNamespace(subsettedProperty:UML::Property):Boolean{
	if(self=subsettedProperty)then {return false;}endif;
	var affiliation:UML::Property=self.getSubstitutionGroupAffiliation();
	if(affiliation.oclIsUndefined())then{return false;}endif;
	// do not include if crossing namespaces
	if(affiliation.getNearestPackage()<>subsettedProperty.getNearestPackage())then{return false;}endif;
	return (affiliation=subsettedProperty) or affiliation.subsetsSourceInNamespace(subsettedProperty);
	}
*/

helper 	XSD::XSDSchema::contentmapAbstractXSDSchemaContent(targetPackage:UML::Package)
{
	if(expandSchemaContent)then{
		self.contents.mapAbstractXSDSchemaContent(targetPackage);
	}else{
	// defer processing of all but imports
	self.contents
	->select(c|c.oclIsKindOf(XSD::XSDSchemaDirective)).oclAsType(XSD::XSDSchemaDirective)	
	->forEach(content){
// 			content.mapAbstractXSDSchemaContent(targetPackage);
			if(content.oclIsKindOf(XSD::XSDImport))then{
	 			content.map AbstractXSDSchemaDirective(targetPackage);
			}else{
				if(content.oclIsKindOf(XSD::XSDInclude))then{
		////////////////////////////////
					var xsdInclude:XSD::XSDInclude=content.oclAsType(XSD::XSDInclude);
					var schemaIncluded:XSD::XSDSchema=xsdInclude.resolvedSchema;
					if(schemaIncluded.oclIsUndefined())then{
						log('ERROR: failed to resolve schema at '+xsdInclude.schemaLocation+' from '+self.targetNamespace+' at '+self.schemaLocation);
					}else{
									schemaIncluded.mapAbstractXSDSchema();
					/*
							// if targetNamespace undefined or same as this schema, try to find a resolved schema via element types
							// this would only work if there was a single include, plus schema map not set to schemaRef
							if(schemaIncluded.targetNamespace.oclIsUndefined() or (schemaIncluded.targetNamespace=self.targetNamespace))then{
								var schemaRef:XSD::XSDSchema=self.elementDeclarations.type.schema
				//				->select(s|s.schemaLocation=schemaIncluded.schemaLocation)
								->select(s|(s.schemaLocation<>self.schemaLocation) and (s.targetNamespace=self.targetNamespace))
								->asSequence()->first();
								if(not(schemaRef.oclIsUndefined()))then{
									//var packageImport:UML::PackageImport=new UML::PackageImport();
									//packageImport.importingNamespace:=targetPackage;
									//schemaIncluded:=schemaRef;		
									//packageImport.importedPackage:=
									schemaIncluded.mapAbstractXSDSchema();
									log('TEST: replaced schemaInclude for '+schemaIncluded.targetNamespace+' at '+schemaIncluded.schemaLocation+' from '+self.schemaLocation);			
								}endif;
							}endif;
						*/	
						}endif;

				}endif;
			}endif;
 			
 		};
 	}endif;	
	return;
}

////////////////////
helper XSD::XSDSchema::mapAbstractXSDSchema():UML::Package{
	return self.map AbstractXSDSchema();
}
helper XSD::XSDSchemaContent::mapAbstractXSDSchemaContent(umlContainer:UML::Element):UML::Element{
	switch{
		case(self.oclIsKindOf(XSD::XSDAnnotation)){
			self.oclAsType(XSD::XSDAnnotation).mapXSDAnnotation(umlContainer);
        	return null;
        	};
	};
	var umlContent:UML::Element=self.map AbstractXSDSchemaContent(umlContainer);
 	return umlContent;
 	}
helper UML::Package::applyNIEMSchemaStereotype():Stdlib::Element{
	return self.ApplyStereotype(NIEMInformationModelStereotype);
}
helper XSD::XSDSchema::setModelInformationDefaultPurpose(fileTypePurposeURI:String,pimNdrSchemaInstance:Stdlib::Element){
	var defaultPurpose:String='extension';
	var schemaKind:String=null;
	if(not(fileTypePurposeURI.oclIsUndefined()))then{schemaKind:=fileTypePurposeURI.substringAfter('#').replace('-schema','');}endif;
	if(schemaKind.oclIsUndefined())then{
		if(self.targetNamespace.startsWith(baseNiemNamespace)
			or self.targetNamespace.startsWith(baseNiemNamespaceNiem2) 
			or (self.targetNamespace='urn:us:gov:ic:ism:v2') )then{
			defaultPurpose:='subset';
			
		}endif;
	}else{
		defaultPurpose:=schemaKind;
	}endif;
	pimNdrSchemaInstance.setInformationModelDefaultPurpose(defaultPurpose);
	 	return;
	 }
/////////////////////////////////////////////////////////////////////////////////////
property pimRoot:UML::Model=null;
property mpdRootPackage:UML::Package=null;
property mpdComponent:UML::Component=null;

///////////////////

helper XSD::XSDSchemaContent::resolveSchemaContentReference():UML::NamedElement{
	var umlSchema:UML::Package=self.schema.mapAbstractXSDSchema();
	if(umlSchema.oclIsUndefined())then{
		// for schema for schema or proxy, get xml primitives library
		var targetNamespace:String=self.schema.targetNamespace;
		if(self.oclIsKindOf(XSD::XSDTypeDefinition) and ((targetNamespace=schemaForSchemaNamespace)or(targetNamespace.isProxySchemaNamespace())))then{
			umlXmlLibrary.ownedType->select(t|t.name.toUpper()=self.oclAsType(XSD::XSDTypeDefinition).name.toUpper())->forEach(type){return type;}
		}else{
			if(targetNamespace.isStructuresSchemaNamespace())then{
			}else{
				log('resolveSchemaContentReference FAILED to map schema '+self.schema.targetNamespace+' from '+self.repr());
			}endif;
		}endif;
		return null;
	}endif;
	var resolvedType:UML::NamedElement= self.mapAbstractXSDSchemaContent(umlSchema).oclAsType(UML::NamedElement);
	return resolvedType;
}

/////////////////////////////////////////////////mapping disjuncts

mapping XSD::XSDSchema::AbstractXSDSchema():UML::Package
	disjuncts XSD::XSDSchema::MPDSchema
	{}
mapping 	XSD::XSDSchemaContent::AbstractXSDSchemaContent(umlContainer:UML::Element):UML::Element 
disjuncts 
	XSD::XSDElementDeclaration::NDRElementDeclaration_topLevel,
	XSD::XSDElementDeclaration::XSDElementDeclaration_augmentation,
	XSD::XSDElementDeclaration::XSDElementDeclaration_roleOf,	
	XSD::XSDElementDeclaration::NDRElementDeclaration,
	//XSD::XSDAttributeDeclaration::XSDAttributeDeclaration_sequenceId,
	XSD::XSDAttributeDeclaration::NDRAttributeDeclaration,
	XSD::XSDRedefineContent::NDRAbstractXSDRedefineContent
	{}
mapping XSD::XSDRedefineContent::NDRAbstractXSDRedefineContent(umlContainer:UML::Element):UML::Element
disjuncts XSD::XSDAnnotation::XSDAnnotation,
	XSD::XSDRedefinableComponent::NDRAbstractXSDRedefinableComponent
	{}
mapping XSD::XSDRedefinableComponent::NDRAbstractXSDRedefinableComponent(umlContainer:UML::Element):UML::PackageableElement
disjuncts 
	XSD::XSDAttributeGroupDefinition::NDRAbstractXSDAttributeGroupDefinition,
	XSD::XSDTypeDefinition::NDRAbstractXSDTypeDefinition,
	XSD::XSDModelGroupDefinition::XSDModelGroupDefinition
	{}
mapping 	XSD::XSDTypeDefinition::NDRAbstractXSDTypeDefinition(umlContainer:UML::Element):UML::Classifier
disjuncts XSD::XSDComplexTypeDefinition::NDRAbstractXSDComplexTypeDefinition,
	XSD::XSDSimpleTypeDefinition::NDRAbstractXSDSimpleTypeDefinition  {}
mapping XSD::XSDComplexTypeDefinition::NDRAbstractXSDComplexTypeDefinition(umlContainer:UML::Element):UML::Classifier
	disjuncts 
	
	XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinition_Enumeration,

	XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinition_PrimitiveType,
	XSD::XSDComplexTypeDefinition::NDRComplexTypeDefinitionDataType,

	XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_AssociationType,
	XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_AugmentationType,
	XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_MetadataType,
	XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_AdapterType,
	
//	XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_ObjectTypeExplicit,
	XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_ObjectType
	{}
mapping XSD::XSDSimpleTypeDefinition::NDRAbstractXSDSimpleTypeDefinition(umlContainer:UML::Element):UML::Classifier 
disjuncts 
	XSD::XSDSimpleTypeDefinition::XSDTypeDefinition_Enumeration,
	XSD::XSDSimpleTypeDefinition::XSDTypeDefinition_UnionType,
	XSD::XSDSimpleTypeDefinition::XSDTypeDefinition_ListType,
	XSD::XSDSimpleTypeDefinition::XSDTypeDefinition_PrimitiveType,
	XSD::XSDSimpleTypeDefinition::NDRSimpleTypeDefinitionDataType
	{}
mapping 	XSD::XSDAttributeGroupDefinition::NDRAbstractXSDAttributeGroupDefinition(umlContainer:UML::Element):UML::Class 
disjuncts XSD::XSDAttributeGroupDefinition::NDRAttributeGroupDefinition,
	XSD::XSDAttributeGroupDefinition::XSDAttributeGroupDefinition
	{}

mapping 	XSD::XSDTypeDefinition::AbstractXSDTypeDefinition(umlContainer:UML::Element):UML::Classifier
disjuncts XSD::XSDComplexTypeDefinition::AbstractXSDComplexTypeDefinition,
	XSD::XSDSimpleTypeDefinition::AbstractXSDSimpleTypeDefinition  {}
mapping XSD::XSDComplexTypeDefinition::AbstractXSDComplexTypeDefinition(umlContainer:UML::Element):UML::Classifier
	disjuncts
//	XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinitionDataType,
	XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinition_Enumeration,
	XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinition_PrimitiveType,
	XSD::XSDComplexTypeDefinition::NDRComplexTypeDefinitionDataType,
	XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinition

	{}
mapping XSD::XSDSimpleTypeDefinition::AbstractXSDSimpleTypeDefinition(umlContainer:UML::Element):UML::Classifier
disjuncts
	XSD::XSDSimpleTypeDefinition::NDRAbstractXSDSimpleTypeDefinition
	//,
	//XSD::XSDSimpleTypeDefinition::XSDSimpleTypeDefinitionDataType
	{}

mapping XSD::XSDTypeDefinition::AbstractBaseTypeDefinition(general:UML::Classifier,specificClient:UML::Classifier):UML::Element@pimUml
	disjuncts
	XSD::XSDTypeDefinition::BaseTypeDefinition_enumeration,
	XSD::XSDTypeDefinition::BaseTypeDefinition_enumeration_simpleContent,
	XSD::XSDTypeDefinition::BaseTypeDefinition_primitiveType,
	XSD::XSDSimpleTypeDefinition::BaseTypeDefinition_simpleType_simpleContent,
	XSD::XSDComplexTypeDefinition::BaseTypeDefinition_simpleContent_lib,
	XSD::XSDComplexTypeDefinition::BaseTypeDefinition_restriction,
	XSD::XSDTypeDefinition::BaseTypeDefinition_lib
	{}
	
/////////////////////////////////////////////////mapping end disjuncts
mapping 	XSD::XSDSchema::MPDSchema_init():UML::Package@pimUml 
	inherits XSD::XSDSchema::XSDSchema
{
	init{
	var ownerPackage:UML::Package=self.relativeMdpLocation().getOwnerPackage(mpdRootPackage);
	ownerPackage.packagedElement+=result;
	}
}
mapping 	XSD::XSDSchema::MPDSchema():UML::Package@pimUml 
	inherits XSD::XSDSchema::MPDSchema_init
	when{self.isMapped()}
{
	///////////////////
		var pimNdrSchemaInstance:Stdlib::Element=result.applyNIEMSchemaStereotype();
		//log("informationModel "+pimNdrSchemaInstance.repr());
		// set version, conformant, purpose
		pimNdrSchemaInstance.setSchemaAppinfoConformantIndicator(self.appinfoConformantIndicator());
		var version:String=self.version;
		if(version.oclIsUndefined())then{version:="1";}endif;
		pimNdrSchemaInstance.setSchemaVersion(version);
		pimNdrSchemaInstance.setSchemaNamespace(self.targetNamespace);
	
		self.setModelInformationDefaultPurpose(null,pimNdrSchemaInstance);
		//////////////
	// process LocalTerminology
	var localTerm:Sequence(OclAny)=self.annotations.getXSDAnnotationApplicationInformation().getElementElements()->select(i|i.isLocalTermElement());
	if(localTerm->notEmpty())then{
		self.map LocalVocabulary(result);
	}endif;
}
/*
mapping XSD::XSDSchema::LocalVocabularyPackage(inout umlOwningPackage:UML::Package):UML::Package@pimUml
{
	name:='LocalVocabulary';
	umlOwningPackage.packagedElement+=result;
	self.map LocalVocabulary(result);
}
*/
mapping XSD::XSDSchema::LocalVocabulary(inout umlOwningPackage:UML::Package):UML::Enumeration@pimUml
{
	name:='LocalVocabulary';
	umlOwningPackage.packagedElement+=result;
	result.ApplyStereotype(NIEMLocalVocabularyStereotype);
	self.annotations.getXSDAnnotationApplicationInformation().getElementElements()
		->select(i|i.isLocalTermElement()).map LocalTerm(result);
}
mapping OclAny::LocalTerm(inout umlOwningEnumeration:UML::Enumeration):UML::EnumerationLiteral@pimUml
{
	umlOwningEnumeration.ownedLiteral+=result;
	/*
	SourceText[0..*]  is represented as UML ownedComment.body
term[1..1]  is represented as UML name 
literal[0..1]  is represented as UML  specification.name
definition[0..1] is represented as UML specification.oclAsType(UML::StringLiteral).value
sourceURIs[1..*]  is represented as the tag sourceURIs on the applied Stereotype <<Source>>
	*/
	name:=self.getTermTerm();
	var termLiteral:String:=self.getTermLiteral();
	var termDefinition:String:=self.getTermDefinition();
	var termSourceText:Sequence(String):=self.getTermSourceText();
	var sourceURIs:Sequence(String):=self.getTermSourceURIs();
	var sourceInstance:Stdlib::Element=result.ApplyStereotype(NIEMLocalTermStereotype);
	
	if(not((termLiteral=null)or termLiteral.oclIsUndefined()))then{
		sourceInstance.setLocalTermLiteral(termLiteral);
	}endif;
	if(not((termDefinition=null)or termDefinition.oclIsUndefined()))then{
		sourceInstance.setLocalTermDefinition(termDefinition);
	}endif;
	termSourceText.map TermSourceText(result);
	sourceURIs.addTermSourceURI(sourceInstance);
}
/*
mapping OclAny::TermSpecification(inout umlOwningEnumerationLiteral:UML::EnumerationLiteral,termLiteral:String,termDefinition:String):UML::LiteralString@pimUml
{
	//	log('termLiteral '+termLiteral+', '+termDefinition);
	umlOwningEnumerationLiteral.specification:=result;
	if(not((termLiteral=null)or termLiteral.oclIsUndefined()))then{
	name:=termLiteral;
	}endif;
	if(not((termDefinition=null)or termDefinition.oclIsUndefined()))then{
	value:=termDefinition;
	}endif;
}
*/
mapping String::TermSourceText(inout umlOwningEnumerationLiteral:UML::EnumerationLiteral):UML::Comment@pimUml
{
	umlOwningEnumerationLiteral.ownedComment+=result;
	body:=self;
}
mapping XSD::XSDElementDeclaration::XSDElementDeclaration_augmentation(umlOwningClass:UML::Element):UML::Property@pimUml
	inherits XSD::XSDElementDeclaration::NDRElementDeclaration
	when{
		 self.elementDeclarationReference
		and not(self.resolvedElementDeclaration.type.oclIsUndefined())
		and self.resolvedElementDeclaration.type.oclIsKindOf(XSD::XSDComplexTypeDefinition)
		and self.resolvedElementDeclaration.type.oclAsType(XSD::XSDComplexTypeDefinition).isAugmentationType()
	}
{
//	self.resolvedElementDeclaration.applyAppliesToAugmentation(result.oclAsType(UML::NamedElement));
}
mapping XSD::XSDElementDeclaration::XSDElementDeclaration_roleOf(umlOwningClass:UML::Element):UML::Property@pimUml
	inherits XSD::XSDElementDeclaration::NDRElementDeclaration
	when{self.resolvedElementDeclaration.name.startsWith('RoleOf')}
{
}
/*
mapping XSD::XSDAttributeDeclaration::XSDAttributeDeclaration_sequenceId(umlOwningClass:UML::Element):UML::Property@pimUml
	inherits XSD::XSDAttributeDeclaration::NDRAttributeDeclaration
	when{
		(self.resolvedAttributeDeclaration.name='sequenceID')
		and self.attributeDeclarationReference
		and (self.resolvedAttributeDeclaration.schema.targetNamespace=structuresSchemaNamespaceNiem2)
	}
{
	var targetStereotypeInstance:Stdlib::Element=result.ApplyStereotype(NIEMSequenceIdStereotype);
}
*/
mapping 	XSD::XSDElementDeclaration::NDRElementDeclaration_topLevel(umlOwningClass:UML::Element):UML::Property@pimUml 
 	inherits XSD::XSDElementDeclaration::XSDElementDeclaration
 	// if abstract, untyped, or part of cluster, or ref'd by external or ref'd more than once or not at all
 	// other cases may be trimmed during propertyholder update pass
 	when {not(self.elementDeclarationReference)
 	}
{
	// multiplicity nominally does not matter as top level element, 
	// however, to support instance document construction for substitutionGroups and cross-namespace resolution
	//		we need to allow unconstrained multiplicity
	result.setUpper(-1);
	result.setLower(0);
	// the appliesTo should really be at the top level
	// no appliesTo for augmentations in niem3, appliesTo now  for metadata elements
	/*
	if(not(self.type.oclIsUndefined())
		and self.type.oclIsKindOf(XSD::XSDComplexTypeDefinition)
		and self.type.oclAsType(XSD::XSDComplexTypeDefinition).isAugmentationType()
	)then{
		self.applyAppliesToAugmentation(result.oclAsType(UML::NamedElement));
	}endif;
	*/	
		//	self.applyAppliesToMetadata(result); // from element in niem3
	if(not(self.type.oclIsUndefined())
		and self.type.oclIsKindOf(XSD::XSDComplexTypeDefinition)
		and self.type.oclAsType(XSD::XSDComplexTypeDefinition).isMetadataType()
	)then{
		self.applyAppliesToMetadata(result.oclAsType(UML::NamedElement));
	}endif;
	
	
}
mapping 	XSD::XSDElementDeclaration::NDRElementDeclaration(umlOwningClass:UML::Element):UML::Property@pimUml 
 	inherits XSD::XSDElementDeclaration::XSDElementDeclaration
 	when {self.elementDeclarationReference}
{
}
mapping 	XSD::XSDComplexTypeDefinition::NDRComplexTypeDefinitionDataType(umlContainer:UML::Element):UML::DataType@pimUml 
 	inherits XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinitionDataType,
 	XSD::XSDComplexTypeDefinition::NDRComplexTypeDefinitionCommon
 	when{not(self.content.oclIsUndefined()) and self.content.oclIsKindOf(XSD::XSDSimpleTypeDefinition)}
{
}	
mapping 	XSD::XSDComplexTypeDefinition::NDRComplexTypeDefinition(umlContainer:UML::Element):UML::Class@pimUml 
 	inherits XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinition,
 	XSD::XSDComplexTypeDefinition::NDRComplexTypeDefinitionCommon
{
}	

mapping 	XSD::XSDComplexTypeDefinition::NDRComplexTypeDefinitionCommon(umlContainer:UML::Element):UML::Classifier@pimUml
	inherits XSD::XSDTypeDefinition::NDRTypeDefinition 
{
	init{}
}	

mapping 	XSD::XSDTypeDefinition::NDRTypeDefinition(umlContainer:UML::Element):UML::Classifier@pimUml 
{
	init{}
}	
mapping 	XSD::XSDSimpleTypeDefinition::NDRSimpleTypeDefinitionDataType(umlContainer:UML::Element):UML::DataType@pimUml 
 	inherits XSD::XSDSimpleTypeDefinition::XSDSimpleTypeDefinitionDataType,XSD::XSDTypeDefinition::NDRTypeDefinition
{
	init{}
}	

mapping XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinition_Enumeration(umlContainer:UML::Element):UML::Enumeration@pimUml 
 	inherits XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinitionDataType,
	 	XSD::XSDComplexTypeDefinition::NDRComplexTypeDefinitionCommon
	when{self.isEnumeration()}
	{
}
mapping XSD::XSDSimpleTypeDefinition::XSDTypeDefinition_Enumeration(umlContainer:UML::Element):UML::Enumeration@pimUml 
	inherits XSD::XSDSimpleTypeDefinition::XSDSimpleTypeDefinitionDataType,
		XSD::XSDTypeDefinition::NDRTypeDefinition
	when{self.isEnumeration()}
	{
	self.mapXSDEnumerationFacet(result);
}

helper XSD::XSDSimpleTypeDefinition::mapXSDEnumerationFacet(psmOwner:UML::Enumeration){
	var enumFacets:OrderedSet(XSD::XSDEnumerationFacet)=self.enumerationFacets;
	log('mapXSDEnumerationFacet '+psmOwner.qualifiedName+', size='+enumFacets->size().repr());
	enumFacets->forEach(facet){
		var umlEnumLiteral:UML::EnumerationLiteral=new UML::EnumerationLiteral@pimUml();
		umlEnumLiteral.name:=facet.value->asSequence()->first().repr();
		umlEnumLiteral.enumeration:=psmOwner;
		facet.annotation.mapXSDAnnotation(umlEnumLiteral);
	};
	return;
}
mapping 	XSD::XSDAttributeDeclaration::NDRAttributeDeclaration(umlContainer:UML::Element):UML::Property@pimUml 
 	inherits XSD::XSDAttributeDeclaration::XSDAttributeDeclaration
{
	var targetStereotypeInstance:Stdlib::Element=result.ApplyStereotype(NIEMPropertyStereotype);
	targetStereotypeInstance.setNIEMPropertyKind('attribute');
}

mapping 	XSD::XSDAttributeGroupDefinition::NDRAttributeGroupDefinition(umlContainer:UML::Element):UML::Class@pimUml 
 	inherits XSD::XSDAttributeGroupDefinition::XSDAttributeGroupDefinition
{
}
/////////////////////////////////////////////////end mapping
// override to add ndrProfile
query XSD::XSDComplexTypeDefinition::isAugmentationType():Boolean=
	switch{
		case(
			(not(self.annotation.oclIsUndefined())and self.annotation.isAppinfoStructuresAugmentationTypeBase())
			 or( // NIEM2
			(self.name='AugmentationType') and (self.schema.targetNamespace.isStructuresSchemaNamespace())
			)
			) true;
		case(not(
			self.baseTypeDefinition.oclIsUndefined()
			or not(self.baseTypeDefinition.oclIsKindOf(XSD::XSDComplexTypeDefinition))
			or (self.baseTypeDefinition=self)
			)) self.baseTypeDefinition.oclAsType(XSD::XSDComplexTypeDefinition).isAugmentationType();
		else false;	
	};
	/*
query XSD::XSDComplexTypeDefinition::isObjectType():Boolean=
	switch{
//		case(self.annotation.isAppinfoStructuresObjectBase()) true;
		case(not(
			self.baseTypeDefinition.oclIsUndefined()
			or not(self.baseTypeDefinition.oclIsKindOf(XSD::XSDComplexTypeDefinition))
			or (self.baseTypeDefinition=self)
			)) self.baseTypeDefinition.oclAsType(XSD::XSDComplexTypeDefinition).isObjectType();
		else false;	
	};
	*/

query XSD::XSDComplexTypeDefinition::isMetadataType():Boolean=
	switch{
		case(self.annotation.isAppinfoMetadataTypeBase()) true; // NIEM2
		case(
			(self.name='MetadataType') and (self.schema.targetNamespace.isStructuresSchemaNamespace())
			//)
			) true;
		case(not(
			self.baseTypeDefinition.oclIsUndefined()
			or not(self.baseTypeDefinition.oclIsKindOf(XSD::XSDComplexTypeDefinition))
			or (self.baseTypeDefinition=self)
			)) self.baseTypeDefinition.oclAsType(XSD::XSDComplexTypeDefinition).isMetadataType();
		else false;	
	};


query XSD::XSDComplexTypeDefinition::isAssociationType():Boolean=
	switch{
		case(self.annotation.isAppinfoAssociationTypeBase()) true;// NIEM2
		case(
			(self.name='AssociationType') and (self.schema.targetNamespace.isStructuresSchemaNamespace())
			//)
			) true;
		case(not(
			self.baseTypeDefinition.oclIsUndefined()
			or not(self.baseTypeDefinition.oclIsKindOf(XSD::XSDComplexTypeDefinition))
			or (self.baseTypeDefinition=self)
			)) self.baseTypeDefinition.oclAsType(XSD::XSDComplexTypeDefinition).isAssociationType();
		else false;	
	};

///////////////////////////////////////////////utility queries
/* not referenced
query XSD::XSDAnnotation::getAppinfoAugmentedTypeIndicator():Boolean{
/ * TODO: temporary suppress
	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoAugmentedTypeIndicator())
	->forEach(conformantIndicatorElement){
		return conformantIndicatorElement.getXSDElementValue().asBoolean();
	};
	* /
	return false;
};
*/
// NIEM2
query XSD::XSDAnnotation::getAppinfoAugmentedElementIndicator():Boolean{

	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoAugmentedElementIndicator())
	->forEach(conformantIndicatorElement){
		return conformantIndicatorElement.getXSDElementValue().asBoolean();
	};

	return false;
};
// niem2
query XSD::XSDSchema::appinfoConformantIndicatorNiem2():Boolean{
        self.contents
        ->select(a|a.oclIsKindOf(XSD::XSDAnnotation)).oclAsType(XSD::XSDAnnotation).getXSDAnnotationApplicationInformation().getElementElements()
        ->select(i|i.isAppinfoConformantIndicatorElement())
        ->forEach(conformantIndicatorElement){
                return conformantIndicatorElement.getXSDElementValue().asBoolean();
        };
        return false;// default to false if not defined
};

query XSD::XSDSchema::appinfoConformantIndicator():Boolean{
	if(self.getConformanceTarget().oclIsUndefined())then{return self.appinfoConformantIndicatorNiem2();}endif;
	return true;
	//return not(self.getConformanceTarget().oclIsUndefined());
};
query XSD::XSDConcreteComponent::getConformanceTarget():Stdlib::Element{
	self.getElement().getElementAttributes()->select(e|e.isConformanceTarget())->forEach(ct){return ct;};
	return null;
	 }
query Stdlib::Element::isConformanceTarget():Boolean=
	(self.getAttributeNamespace()=ConformanceTargetNamespace)
	and (self.getAttributeName()=ConformanceTargetsAttributeName)
	 ;

query XSD::XSDImport::appinfoConformantIndicator():Boolean{
	self.getElement().getElementAttributes()
//		->select(e|e.isExternalImportIndicatorAttribute() and (e.oclAsType(OclAny).getXSDAttributeValue().asBoolean()))
		->select(e|e.isExternalImportIndicatorAttribute() and (e.oclAsType(OclAny).getAttributeValue().asBoolean()))
		->forEach(nonConformant){return false;};
	return true;// default to true if not defined
};

helper  Stdlib::Element::setComplexTypeDefinitionMixed(mixed:Boolean){
}
/*
helper XSD::XSDAnnotation::applyAppliesToAugmentation(element:UML::NamedElement){
	self.getXSDAnnotationApplicationInformation().getElementElements()
		->select(i|i.isAppinfoAppliesToElement()).map AugmentationApplication(element,self);
	return;	
}
helper XSD::XSDAnnotation::applyAppliesToMetadata(element:UML::NamedElement){
	self.getXSDAnnotationApplicationInformation().getElementElements()
		->select(i|i.isAppinfoAppliesToElement() and not(i.isAppliesToGeneric()))
		.map MetadataApplication(element,self);
	return;	
}
*/
/* not for augmentations in niem3
helper XSD::XSDConcreteComponent::applyAppliesToAugmentation(element:UML::NamedElement){
	self.getElement().getElementAttributes()
		->select(e|e.isAppinfoAppliesToTypesAttribute())
		.map AugmentationApplication(element,self);
	return;	
}
*/
helper XSD::XSDConcreteComponent::applyAppliesToMetadata(element:UML::NamedElement){
	self.getElement().getElementAttributes()
		->select(e|e.isAppinfoAppliesToTypesAttribute() and not(e.isAppliesToGeneric()))
		.map MetadataApplication(element,self);
	self.getElement().getElementAttributes()
		->select(e|e.isAppinfoAppliesToElementsAttribute() and not(e.isAppliesToGeneric()))
		.map MetadataElementApplication(element,self);
	return;	
}

helper OclAny::assertHasAppliesToType(context:XSD::XSDConcreteComponent):Boolean{
	var appliesToTypeXSD:XSD::XSDTypeDefinition=self.referencedTypeDefinition(context);
	if(appliesToTypeXSD.oclIsUndefined())then{
		log('ERROR: referenced  appliesTo component not found from '+context.container.repr());
		return false;
	}endif;
	return true;
	
}
helper OclAny::assertHasAppliesToElements(context:XSD::XSDConcreteComponent):Boolean{
	var appliesToTypeXSD:XSD::XSDElementDeclaration=self.referencedElementDeclaration(context);
	if(appliesToTypeXSD.oclIsUndefined())then{
		log('ERROR: referenced  appliesTo component not found from '+context.container.repr());
		return false;
	}endif;
	return true;
	
}
mapping OclAny::AugmentationApplication(element:UML::NamedElement,context:XSD::XSDConcreteComponent):UML::Usage@pimUml
	when{self.assertHasAppliesToType(context)}
{
	name:='appliesTo';
	
	element.getNearestPackage().packagedElement+=result;
	var appliesToTypeXSD:XSD::XSDTypeDefinition=self.referencedTypeDefinition(context);
	var umlTypeSchema:UML::Package=appliesToTypeXSD.schema.mapAbstractXSDSchema();
	var appliesToType:UML::NamedElement=
		appliesToTypeXSD.mapAbstractXSDSchemaContent(umlTypeSchema).oclAsType(UML::NamedElement);
	
	supplier+=appliesToType;
	client+=element;
	result.ApplyStereotype(NIEMAugmentationApplicationStereotype);
}

mapping OclAny::MetadataApplication(element:UML::NamedElement,context:XSD::XSDConcreteComponent):UML::Usage@pimUml
	when{self.assertHasAppliesToType(context)}
	
{
	name:='appliesToTypes';
	
	element.getNearestPackage().packagedElement+=result;
	var appliesToTypeXSD:XSD::XSDTypeDefinition=self.referencedTypeDefinition(context);
	var umlTypeSchema:UML::Package=appliesToTypeXSD.schema.mapAbstractXSDSchema();
	var appliesToType:UML::NamedElement=
		appliesToTypeXSD.mapAbstractXSDSchemaContent(umlTypeSchema).oclAsType(UML::NamedElement);
	supplier+=appliesToType;
	client+=element;
	result.ApplyStereotype(NIEMMetadataApplicationStereotype);
	
}

mapping OclAny::MetadataElementApplication(element:UML::NamedElement,context:XSD::XSDConcreteComponent):UML::Usage@pimUml
	when{self.assertHasAppliesToElements(context)}
	
{
	name:='appliesToElements';
	
	element.getNearestPackage().packagedElement+=result;
	var appliesToTypeXSD:XSD::XSDElementDeclaration=self.referencedElementDeclaration(context);
	var umlTypeSchema:UML::Package=appliesToTypeXSD.schema.mapAbstractXSDSchema();
	var appliesToType:UML::NamedElement=
		appliesToTypeXSD.mapAbstractXSDSchemaContent(umlTypeSchema).oclAsType(UML::NamedElement);
	supplier+=appliesToType;
	client+=element;
	result.ApplyStereotype(NIEMMetadataApplicationStereotype);
	
}
query XSD::XSDComplexTypeDefinition::isRole():Boolean=
	self.resolvedElements()->exists(e|e.name.startsWith('RoleOf'));

query XSD::XSDComplexTypeDefinition::resolvedElements():Sequence(XSD::XSDElementDeclaration)=
	self.content->select(c|c.oclIsKindOf(XSD::XSDParticle)).oclAsType(XSD::XSDParticle).resolvedElements()->asSequence();
query XSD::XSDParticle::resolvedElements():Sequence(XSD::XSDElementDeclaration)=self.content.resolvedElements();
query XSD::XSDParticleContent::resolvedElements():Sequence(XSD::XSDElementDeclaration)=
	switch{
		case(self.oclIsKindOf(XSD::XSDElementDeclaration))  Sequence{self.oclAsType(XSD::XSDElementDeclaration).resolvedElementDeclaration};
		case(self.oclIsKindOf(XSD::XSDModelGroup))  self.oclAsType(XSD::XSDModelGroup).contents.resolvedElements();
		case(self.oclIsKindOf(XSD::XSDModelGroupDefinition))  self.oclAsType(XSD::XSDModelGroupDefinition).resolvedModelGroupDefinition.modelGroup.contents.resolvedElements();
		else Sequence{};
	};
query XSD::XSDConcreteComponent::isAppinfoExternalAdapterTypeIndicator():Boolean=
	not(self.getElement().getElementAttributes()
		->select(e|e.isAppinfoExternalAdapterTypeIndicatorAttribute() 
// TEST	suppres			and e.oclAsType(OclAny).getXSDAttributeValue().asBoolean()
				)
		->isEmpty());

query XSD::XSDAnnotation::getAppinfoDeprecated():Boolean{
	self.getElement().getElementAttributes()
	->select(i|i.isAppinfoDeprecatedAttribute())
	->forEach(conformantIndicatorElement){
//		return conformantIndicatorElement.getXSDAttributeValue().asBoolean();
		return conformantIndicatorElement.getAttributeValue().asBoolean();
	};
	return false;
};
	
/*	
query XSD::XSDAnnotation::isAppinfoExternalAdapterTypeIndicator():Boolean=
	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoExternalAdapterTypeIndicatorElement())->notEmpty();
*/
/*
query XSD::XSDAnnotation::isAppinfoAppliesTo():Boolean=
	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoAppliesToElement())->notEmpty();

query XSD::XSDAnnotation::isAppinfoReferenceTarget():Boolean=
	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoReferenceTargetElement())->notEmpty();
*/
// NIEM2
query XSD::XSDAnnotation::isAppinfoMetadataTypeBase():Boolean=
	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoBaseElement() and(
			i.hasAppinfoStructuresAttribute('MetadataType')
			or (
				(i.referencedTypeDefinition(self)<>self.container)
				and i.referencedTypeDefinition(self).annotation.isAppinfoMetadataTypeBase()
			)
		))->notEmpty();
// NIEM2
query XSD::XSDAnnotation::isAppinfoAssociationTypeBase():Boolean=
	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoBaseElement() and(
			i.hasAppinfoStructuresAttribute('Association')
			or (
				(i.referencedTypeDefinition(self)<>self.container)
				and i.referencedTypeDefinition(self).annotation.isAppinfoAssociationTypeBase()
			)	
		))->notEmpty();

// NIEM2
query XSD::XSDAnnotation::isAppinfoStructuresAugmentationTypeBase():Boolean=
	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoBaseElement() and i.hasAppinfoStructuresAttribute('AugmentationType'))->notEmpty();
	/*
query XSD::XSDAnnotation::isAppinfoStructuresMetadataTypeBase():Boolean=
	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoBaseElement() and i.hasAppinfoStructuresAttribute('MetadataType'))->notEmpty();

query XSD::XSDAnnotation::getAppinfoBase():String{
	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoBaseElement() and i.hasAppinfoNamespaceAttribute(structuresSchemaNamespaceNiem2)
		and ((i.getAppInfoName()='Object')or(i.getAppInfoName()='Association'))
		)->forEach(i){return i.getAppInfoName();};
	return null;
};
query XSD::XSDAnnotation::isAppinfoStructuresObjectBase():Boolean=
	self.getXSDAnnotationApplicationInformation().getElementElements()
	->select(i|i.isAppinfoBaseElement() and (
		i.hasAppinfoStructuresAttribute('Object')
		or i.referencedTypeDefinition(self).annotation.isAppinfoStructuresObjectBase()
		))
	->notEmpty();
*/	
/* not in niem3
query OclAny::isAppinfoAugmentedTypeIndicator():Boolean=self.isAppinfo2Element() and (self.getElementName()='AugmentedTypeIndicator');
*/

query OclAny::isLocalTermElement():Boolean=self.isTermElement() and (self.getElementName()='LocalTerm');
query OclAny::isTermElement():Boolean=self.getElementNamespace()=LocalTerminologyTargetNamespace;

// NIEM2
query OclAny::isAppinfoAugmentedElementIndicator():Boolean=self.isAppinfo2Element() and (self.getElementName()='AugmentedElementIndicator');

query OclAny::isAppinfoExternalAdapterTypeIndicatorAttribute():Boolean=self.isAppinfoAttribute() and (self.getAttributeName()='externalAdapterTypeIndicator');
query OclAny::isExternalImportIndicatorAttribute():Boolean=self.isAppinfoAttribute() and (self.getAttributeName()='externalImportIndicator');

query OclAny::isAppinfoAppliesToTypesAttribute():Boolean=self.isAppinfoAttribute() and (self.getAttributeName()='appliesToTypes');
query OclAny::isAppinfoAppliesToElementsAttribute():Boolean=self.isAppinfoAttribute() and (self.getAttributeName()='appliesToElements');


query OclAny::isAppinfoDeprecatedAttribute():Boolean=self.isAppinfoAttribute() and (self.getElementName()='deprecated');
//query OclAny::isAppinfoDeprecatedElement():Boolean=self.isAppinfoElement() and (self.getElementName()='Deprecated');
// NIEM2
query OclAny::isAppinfoConformantIndicatorElement():Boolean=self.isAppinfoElement() and (self.getElementName()='ConformantIndicator');
//query OclAny::isAppinfoExternalAdapterTypeIndicatorElement():Boolean=self.isAppinfoElement() and (self.getElementName()='ExternalAdapterTypeIndicator');
// NIEM2
query OclAny::isAppinfoBaseElement():Boolean=self.isAppinfoElement() and (self.getElementName()='Base');
//query OclAny::isAppinfoAppliesToElement():Boolean=self.isAppinfoElement() and (self.getElementName()='AppliesTo');
query OclAny::isAppliesToGeneric():Boolean=self.getAppInfoNamespace().isStructuresSchemaNamespace();
// NIEM2
query OclAny::hasAppinfoStructuresAttribute(name:String):Boolean=self.hasAppinfoNamespaceAttribute(structuresSchemaNamespaceNiem2)and self.hasAppinfoNameAttribute(name);
// NIEM2
query OclAny::isAppinfo2Element():Boolean=self.getElementNamespace()=appinfo2Namespace;// not in niem3
query OclAny::referencedElementDeclaration(context:XSD::XSDConcreteComponent):XSD::XSDElementDeclaration=
	// self is a DOM Element
	self.referencedSchemas(context).contents->select(s|s.oclIsKindOf(XSD::XSDElementDeclaration) and
		(s.oclAsType(XSD::XSDElementDeclaration).name=self.getAppInfoName())
		).oclAsType(XSD::XSDElementDeclaration)
	->asSequence()->first();
//////////////////////////////////////////// 

mapping XSD::XSDComplexTypeDefinition::XSDTypeDefinition_StructuredClassifier(umlContainer:UML::Element):UML::Class@pimUml
	inherits XSD::XSDComplexTypeDefinition::NDRComplexTypeDefinition
		
	{
	init{}
}
mapping XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class(umlContainer:UML::Element):UML::Class@pimUml
	inherits 
	XSD::XSDComplexTypeDefinition::XSDTypeDefinition_StructuredClassifier 
	{
}
mapping XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_AssociationType(umlContainer:UML::Element):UML::Class@pimUml 
	inherits
	 
		XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class,
		XSD::XSDTypeDefinition::XSDTypeDefinition_AssociationType
		when{self.isAssociationType()}
	{
}
mapping XSD::XSDTypeDefinition::XSDTypeDefinition_AssociationType(umlContainer:UML::Element):UML::Classifier@pimUml 
	{
	init{}
	result.ApplyStereotype(NIEMAssociationStereotype);
}
mapping XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_AugmentationType(umlContainer:UML::Element):UML::Class@pimUml 
	inherits 
		XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class,
		XSD::XSDTypeDefinition::XSDTypeDefinition_AugmentationType
		when{self.isAugmentationType()}
	{
}
mapping XSD::XSDTypeDefinition::XSDTypeDefinition_AugmentationType(umlContainer:UML::Element):UML::Classifier@pimUml 
	{
	init{}
	result.ApplyStereotype(NIEMAugmentationStereotype);
//		self.applyAppliesToAugmentation(result);
}
mapping XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_MetadataType(umlContainer:UML::Element):UML::Class@pimUml 
	inherits 
		XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class,
		XSD::XSDTypeDefinition::XSDTypeDefinition_MetadataType
		when{self.isMetadataType()}
	{
}
mapping XSD::XSDTypeDefinition::XSDTypeDefinition_MetadataType(umlContainer:UML::Element):UML::Classifier@pimUml 
	{
	init{}
	result.ApplyStereotype(NIEMMetadataStereotype);
	//	self.applyAppliesToMetadata(result); // from element in niem3
}
mapping XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_AdapterType(umlContainer:UML::Element):UML::Class@pimUml 
	inherits 
		XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class,
		XSD::XSDTypeDefinition::XSDTypeDefinition_AdapterType
		when{self.isAppinfoExternalAdapterTypeIndicator()}
	{
}
mapping XSD::XSDTypeDefinition::XSDTypeDefinition_AdapterType(umlContainer:UML::Element):UML::Classifier@pimUml 
	{
	init{}
	//log('Apply adapter stereotype '+NIEMAdapterStereotype.qualifiedName);
	result.ApplyStereotype(NIEMAdapterStereotype);
}
/*
mapping XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_ObjectTypeExplicit(umlContainer:UML::Element):UML::Class@pimUml 
	inherits 
		XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_ObjectType
		when{self.isObjectType()}
	{
	result.ApplyStereotype(NIEMObjectTypeStereotype);
}
*/
mapping XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class_ObjectType(umlContainer:UML::Element):UML::Class@pimUml 
	inherits 
		XSD::XSDComplexTypeDefinition::XSDTypeDefinition_Class,
		XSD::XSDTypeDefinition::XSDTypeDefinition_ObjectType
	{
}
mapping XSD::XSDTypeDefinition::XSDTypeDefinition_ObjectType(umlContainer:UML::Element):UML::Classifier@pimUml 
	{
	init{}
}
mapping XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinition_PrimitiveType(umlContainer:UML::Element):UML::PrimitiveType@pimUml 
	inherits XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinitionDataType,
		XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinitionCommon
	when{self.isPrimitiveType()} // TODO: isPrimitiveType is not always finding the underlying primitive type
{
	init{
	}
	//self.attributeContents.attributeGroupContent(result,result);
	//self.attributeWildcardContent.map XSDAttributeWildcard(result).name:='anyAttribute';
	//self.syntheticWildcard.map XSDAttributeWildcard(result).name:='anyAttribute';
	// TODO: facets, anonymous type for simple content
}
	
mapping XSD::XSDSimpleTypeDefinition::XSDTypeDefinition_PrimitiveType(umlContainer:UML::Element):UML::PrimitiveType@pimUml 
	inherits XSD::XSDSimpleTypeDefinition::XSDSimpleTypeDefinition
	when{self.isPrimitiveType()}
{
	// need to distinguish between primitives which were simpleTypeDefinitions: so these always get a stereotype
	var psmSimpleTypeDefinitionInstance:Stdlib::Element=result.ApplyStereotype(NIEMSimpleTypeStereotype);
	// TODO: facetContents should also be used with ComplexType with SimpleContent
	if(self.facetContents->notEmpty())then{
	self.facetContents->forEach(rule){
		switch{
			case(rule.oclIsKindOf(XSD::XSDFractionDigitsFacet))
				psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeFractionDigits(rule.oclAsType(XSD::XSDFractionDigitsFacet).value);
			case(rule.oclIsKindOf(XSD::XSDMaxExclusiveFacet))
				psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMaxExclusive(rule.oclAsType(XSD::XSDMaxExclusiveFacet).value.repr());
			case(rule.oclIsKindOf(XSD::XSDMaxInclusiveFacet))
				psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMaxInclusive(rule.oclAsType(XSD::XSDMaxInclusiveFacet).value.repr());
			case(rule.oclIsKindOf(XSD::XSDPatternFacet))
				psmSimpleTypeDefinitionInstance.setNIEMSimpleTypePattern(rule.oclAsType(XSD::XSDPatternFacet).value->asSequence());
			case(rule.oclIsKindOf(XSD::XSDTotalDigitsFacet))
				psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeTotalDigits(rule.oclAsType(XSD::XSDTotalDigitsFacet).value);
			case(rule.oclIsKindOf(XSD::XSDWhiteSpaceFacet)){
				//psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeWhiteSpace(rule.oclAsType(XSD::XSDWhiteSpaceFacet).value.repr());
				var restrictionInstance:Stdlib::Element=result.ApplyStereotype(NIEMRepresentationRestrictionStereotype).oclAsType(Stdlib::Element);
				restrictionInstance.setNIEMSimpleTypeWhiteSpace(rule.oclAsType(XSD::XSDWhiteSpaceFacet).value.repr());
				};
			case(rule.oclIsKindOf(XSD::XSDLengthFacet))
				psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeLength(rule.oclAsType(XSD::XSDLengthFacet).value);
			case(rule.oclIsKindOf(XSD::XSDMinExclusiveFacet))
				psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMinExclusive(rule.oclAsType(XSD::XSDMinExclusiveFacet).value.repr());
			case(rule.oclIsKindOf(XSD::XSDMinInclusiveFacet))
				psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMinInclusive(rule.oclAsType(XSD::XSDMinInclusiveFacet).value.repr());
			case(rule.oclIsKindOf(XSD::XSDMaxLengthFacet))
				psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMaxLength(rule.oclAsType(XSD::XSDMaxLengthFacet).value);
			case(rule.oclIsKindOf(XSD::XSDMinLengthFacet))
				psmSimpleTypeDefinitionInstance.setNIEMSimpleTypeMinLength(rule.oclAsType(XSD::XSDMinLengthFacet).value);
			
		};
	};
	}endif;
}
query XSD::XSDSimpleTypeDefinition::isUnionType():Boolean=self.variety.repr()='union';
query XSD::XSDSimpleTypeDefinition::isListType():Boolean=self.variety.repr()='list';
mapping XSD::XSDSimpleTypeDefinition::XSDTypeDefinition_UnionType(umlContainer:UML::Element):UML::PrimitiveType@pimUml 
	inherits XSD::XSDSimpleTypeDefinition::XSDSimpleTypeDefinition
	when{self.isUnionType()}
{
	result.ApplyStereotype(NIEMUnionTypeStereotype);
}
mapping XSD::XSDSimpleTypeDefinition::XSDTypeDefinition_ListType(umlContainer:UML::Element):UML::PrimitiveType@pimUml 
	inherits XSD::XSDSimpleTypeDefinition::XSDSimpleTypeDefinition
	when{self.isListType()}
{
	result.ApplyStereotype(NIEMListTypeStereotype);
}
query XSD::XSDTypeDefinition::isXmlToken():Boolean{
	switch{
		case(self.oclIsKindOf(XSD::XSDSimpleTypeDefinition)and (self.name='token')and(self.schema.targetNamespace=schemaForSchemaNamespace)){
			return true;
		}
	};
	return false;
}
mapping XSD::XSDTypeDefinition::BaseTypeDefinition_lib(generalSupplier:UML::Classifier,specificClient:UML::Classifier):UML::Generalization@pimUml
	when{
		not(specificClient.oclIsKindOf(UML::Enumeration))
		and (not(self.baseType.schema.targetNamespace.isStructuresSchemaNamespace()))
		and (
				(specificClient.oclIsKindOf(UML::Class) and generalSupplier.oclIsKindOf(UML::Class))
				or(specificClient.oclIsKindOf(UML::PrimitiveType) and generalSupplier.oclIsKindOf(UML::PrimitiveType))
			)
	}
{	
		specific:=specificClient;
		general:=generalSupplier;
}

mapping XSD::XSDComplexTypeDefinition::BaseTypeDefinition_restriction(generalSupplier:UML::Classifier,specificClient:UML::Classifier):UML::Realization@pimUml
	when{
		(self.derivationMethod.repr()='restriction')
		and (specificClient.oclIsKindOf(UML::Class) and generalSupplier.oclIsKindOf(UML::Class))
	}
{	
		client+=specificClient;
		supplier+=generalSupplier;
		specificClient.getNearestPackage().packagedElement+=result;
	result.ApplyStereotype(NIEMRestrictionStereotype);
}

mapping XSD::XSDComplexTypeDefinition::BaseTypeDefinition_simpleContent_lib(generalSupplier:UML::PrimitiveType,specificClient:UML::Classifier):UML::Realization@pimUml
	when{
		not(specificClient.oclIsKindOf(UML::Enumeration))
		and generalSupplier.oclIsKindOf(UML::PrimitiveType)
		
		 and (
		 	not(self.baseTypeDefinition.oclIsKindOf(XSD::XSDComplexTypeDefinition))
		 	or (self.baseTypeDefinition.schema.targetNamespace.isProxySchemaNamespace())
		 )
		 }
{	
	//log('SimpleContent client '+specificClient.qualifiedName);
		client+=specificClient;
		supplier+=generalSupplier;
		specificClient.getNearestPackage().packagedElement+=result;
	result.ApplyStereotype(NIEMSimpleContentStereotype);
}

mapping XSD::XSDTypeDefinition::BaseTypeDefinition_primitiveType(generalSupplier:UML::PrimitiveType,specificClient:UML::PrimitiveType):UML::Generalization@pimUml
	when{
		(not(self.baseType.schema.targetNamespace.isStructuresSchemaNamespace()))
		and generalSupplier.oclIsKindOf(UML::PrimitiveType)
		and specificClient.oclIsKindOf(UML::PrimitiveType)
	}
{	
		specific:=specificClient;
		general:=generalSupplier;
}

mapping XSD::XSDTypeDefinition::BaseTypeDefinition_enumeration(generalSupplier:UML::Enumeration,specificClient:UML::Enumeration):UML::Generalization@pimUml
when{
		 generalSupplier.oclIsKindOf(UML::Enumeration)
		and specificClient.oclIsKindOf(UML::Enumeration)
}
{	
		specific:=specificClient;
		general:=generalSupplier;
}

mapping XSD::XSDTypeDefinition::BaseTypeDefinition_enumeration_simpleContent(general:UML::DataType,specificClient:UML::Enumeration):UML::Realization@pimUml
	when{
		not(self.baseType.isXmlToken())
		and (not(self.baseType.schema.targetNamespace.isStructuresSchemaNamespace()))
		and general.oclIsKindOf(UML::DataType)
		and specificClient.oclIsKindOf(UML::Enumeration)
	}
{	
		client+=specificClient;
		supplier+=general;
		specificClient.getNearestPackage().packagedElement+=result;
		result.ApplyStereotype(NIEMRestrictionStereotype);
		
}
//mapping XSD::XSDSimpleTypeDefinition::BaseTypeDefinition_simpleType_simpleContent(general:UML::DataType,specificClient:UML::Enumeration):UML::Realization@pimUml
mapping XSD::XSDSimpleTypeDefinition::BaseTypeDefinition_simpleType_simpleContent(general:UML::DataType,specificClient:UML::Classifier):UML::Realization@pimUml
	when{
		 (not(self.baseType.schema.targetNamespace.isStructuresSchemaNamespace()))
		and not(specificClient.oclIsKindOf(UML::Enumeration) and self.baseType.isXmlToken())
		 
		and general.oclIsKindOf(UML::PrimitiveType)
		and specificClient.oclIsKindOf(UML::DataType)
		and not(specificClient.oclIsKindOf(UML::PrimitiveType))
	}
{	
		client+=specificClient;
		supplier+=general;
		specificClient.getNearestPackage().packagedElement+=result;
		result.ApplyStereotype(NIEMRestrictionStereotype);
		
}

mapping 	XSD::XSDSchema::XSDSchema():UML::Package@pimUml //inherits XSD::XSDScope::XSDScope
{
	log('XSDSchema '+self.targetNamespace+' at '+self.schemaLocation+', extent '+self.extent().contextURI().repr());
	name:=self.extent().contextURI();
		self.contentmapAbstractXSDSchemaContent(result);
}

mapping 	XSD::XSDAnnotation::XSDAnnotation(inout owner:UML::Element):UML::Comment@pimUml
{
	init{}
	owner.ownedComment+=result;
	annotatedElement+=owner;
}
mapping 	XSD::XSDNotationDeclaration::XSDNotationDeclaration(owner:UML::Element):UML::EnumerationLiteral@pimUml
 	inherits XSD::XSDNamedComponent::XSDNamedComponent
{
	init{}
	owner.oclAsType(UML::Package).packagedElement+=result;
	self.annotation.mapXSDAnnotation(result);
}

mapping 	XSD::XSDIdentityConstraintDefinition::XSDIdentityConstraintDefinition(owner:UML::Element):UML::Constraint@pimUml
 	inherits XSD::XSDNamedComponent::XSDNamedComponent
{
	init{}
	owner->switch(context){
		case (context.oclIsKindOf(UML::Namespace)) context.oclAsType(UML::Namespace).ownedRule+=result;
		else context.owner.oclAsType(UML::Namespace).ownedRule+=result;
	};
	constrainedElement:=owner;
	if(not(self.referencedKey.oclIsUndefined()))then{
		var umlPropertyOwner:UML::Property=self.referencedKey.container.oclAsType(XSD::XSDSchemaContent).resolveSchemaContentReference().oclAsType(UML::Property);
		var constraint:UML::Constraint=self.referencedKey.map XSDIdentityConstraintDefinition(umlPropertyOwner);
		constrainedElement+=constraint;
	}endif;
	self.selector.map XSDXPathDefinition(result);
	self.fields.map XSDXPathDefinition(result);
	self.annotation.mapXSDAnnotation(result);
}
mapping 	XSD::XSDXPathDefinition::XSDXPathDefinition(inout owner:UML::Element):UML::Comment@pimUml
{
	init{}
	owner.ownedComment+=result;
	annotatedElement+=owner;
	self.annotation.mapXSDAnnotation(result);
}
mapping 	XSD::XSDTypeDefinition::XSDTypeDefinition(owner:UML::Element):UML::Classifier@pimUml
 	inherits XSD::XSDRedefinableComponent::XSDRedefinableComponent
{
	init{}
	owner->switch(context){
		case(context.oclIsKindOf(UML::Package))context.oclAsType(UML::Package).packagedElement+=result;
		else context.oclAsType(UML::Class).nestedClassifier+=result;
	};
	self.annotation.mapXSDAnnotation(result);
	self.derivationAnnotation.mapXSDAnnotation(result);
}
mapping 	XSD::XSDSimpleTypeDefinition::XSDSimpleTypeDefinitionDataType(umlContainer:UML::Element):UML::DataType@pimUml
 	inherits XSD::XSDSimpleTypeDefinition::XSDSimpleTypeDefinition
{
	init{}
}

mapping 	XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinitionCommon(umlContainer:UML::Element):UML::Classifier@pimUml
 	inherits XSD::XSDTypeDefinition::XSDTypeDefinition
{
	init{}
	// ownership aestablished by XSDTypeDefinition

	isAbstract:=self._abstract;
	self.contentAnnotation.mapXSDAnnotation(result);
	if(not(
			(self.baseTypeDefinition=null)
			or self.baseTypeDefinition.oclIsUndefined() 
			or (self=self.baseTypeDefinition) 
			or self.baseTypeDefinition.isAnyType()
			))then{
		var resolvedSchemaContentReference:UML::NamedElement=self.baseTypeDefinition.resolveSchemaContentReference();
		if(not(resolvedSchemaContentReference.oclIsUndefined()))then{
			self.map AbstractBaseTypeDefinition(resolvedSchemaContentReference.oclAsType(UML::Classifier),result);
		}else{
			log('XSDComplexTypeDefinitionCommon FAILED to resolved baseTypeDefinition from '+result.qualifiedName);
		}endif;
	}endif;
}
mapping 	XSD::XSDFeature::XSDFeature(umlOwningClassifier:UML::Element):UML::Property@pimUml
 	inherits XSD::XSDNamedComponent::XSDNamedComponent
{
	init{}
	// in case classifier was already established or switched
	if(result.owner.oclIsUndefined())then{
		umlOwningClassifier->switch(context) {
			case (context.oclIsKindOf(UML::Classifier)) context.oclAsType(UML::Classifier).setOwnedAttribute(result);
			else {
				var umlSchema:UML::Package=context.oclAsType(UML::Package);
				var className:String=self.getSchemaFeatureClassName();
				var featureClass:UML::Class=className.getSchemaLevelFeatureClass(umlSchema);
				if(result.owner.oclIsUndefined())then{
					featureClass.setOwnedAttribute(result);
				}endif;	
			};
		};
	}endif;
//	aggregation:=UML::AggregationKind::composite;
	aggregation:=UML::AggregationKind::shared;
}


mapping 	XSD::XSDModelGroupDefinition::XSDModelGroupDefinition(umlContainer:UML::Element):UML::Class@pimUml
 	inherits XSD::XSDRedefinableComponent::XSDRedefinableComponent
{
	init{}
	var modelGroupPackage:UML::Package=self.getSchemaContentPackage();
	modelGroupPackage.packagedElement+=result;
	self.annotation.mapXSDAnnotation(result);
	self.ModelGroupDefinition(result);
	if(result.name.oclIsUndefined())then{name:='nested_ModelGroupDefinition';}endif;
}

mapping 	XSD::XSDAttributeDeclaration::XSDAttributeDeclaration(umlContainer:UML::Element):UML::Property@pimUml
 	inherits XSD::XSDFeature::XSDFeature
{
	init{}
	// ownership set by XSDFeature
	self.resolvedAttributeDeclaration.annotation.mapXSDAnnotation(result);
	if(self.attributeDeclarationReference)then{
		var referencedAttributeDeclaration:XSD::XSDAttributeDeclaration=self.resolvedAttributeDeclaration;
		var referencedUmlAttribute:UML::Property=referencedAttributeDeclaration.resolveSchemaContentReference().oclAsType(UML::Property);
		name:=referencedAttributeDeclaration.name;
		if(not(referencedUmlAttribute.oclIsUndefined()))then{
		self.reference(result,referencedUmlAttribute,'ref');
		}endif;
		var umlType:UML::NamedElement=referencedUmlAttribute.type;
		// in case UML type has not yet been resolved, resolve via map from schema attribute type
		if(umlType.oclIsUndefined())then{
			if(referencedAttributeDeclaration.anonymousTypeDefinition.oclIsUndefined())then{
				umlType:=referencedAttributeDeclaration.typeDefinition.resolveSchemaContentReference();
			}else{
				var umlOwningClass:UML::Class=referencedAttributeDeclaration.umlOwningClassProxy(referencedUmlAttribute);
				umlType:=referencedAttributeDeclaration.anonymousTypeDefinition.map AbstractXSDSchemaContent(umlOwningClass).oclAsType(UML::NamedElement);
			}endif;
		}endif;
		if(not(umlType.oclIsUndefined()))then{
			type:=umlType.oclAsType(UML::Classifier);
		}endif;
		
	}else{
		if(self.anonymousTypeDefinition.oclIsUndefined())then{
			var umlType:UML::NamedElement=self.typeDefinition.resolveSchemaContentReference();
			if(not(umlType.oclIsUndefined()))then{
			type:=umlType.oclAsType(UML::Classifier);
			}endif;
	
		}else{
			var umlOwningClass:UML::Class=self.umlOwningClassProxy(result);
			type:=self.anonymousTypeDefinition.map AbstractXSDSchemaContent(umlOwningClass).oclAsType(UML::Type);
			
		}endif;
	}endif;
}
mapping 	XSD::XSDAttributeGroupDefinition::XSDAttributeGroupDefinition(umlContainer:UML::Element):UML::Class@pimUml
 	inherits XSD::XSDRedefinableComponent::XSDRedefinableComponent
{
	init{}
	// owner is nominally the top level attributeGroupPackage, may become nested in another attributeGroupDefinition
	 var attributeGroupPackage:UML::Package=self.getSchemaContentPackage();
		attributeGroupPackage.packagedElement+=result;
	self.annotation.mapXSDAnnotation(result);
	self.contents.attributeGroupContent(result,result);
	self.attributeWildcardContent.map XSDAttributeWildcard(result).name:='anyAttribute';
	self.syntheticWildcard.map XSDAttributeWildcard(result).name:='anyAttribute';
}

mapping 	XSD::XSDWildcard::XSDWildcard(umlContainer:UML::Element):UML::Property@pimUml
{
	init{}
	// container must be a ComplexTypeDefinition or AttributeGroupDefinition either of which are a Classifier
	umlContainer.oclAsType(UML::Classifier).setOwnedAttribute(result);
		var targetWildcardInstance:Stdlib::Element=result.ApplyStereotype(NIEMAnyPropertyStereotype);
		targetWildcardInstance.setNIEMAnyPropertyProcessContents(
			switch{
				case (self.processContents=XSDProcessContents::lax)'lax';
				case (self.processContents=XSDProcessContents::strict)'strict';
				else 'skip';
				}
			);
		if(self.lexicalNamespaceConstraint->notEmpty())	then{
			self.lexicalNamespaceConstraint
				->forEach(namespaceConstraint){
					targetWildcardInstance.setNIEMAnyPropertyValueNamespace(namespaceConstraint);
				};
		}else{
					targetWildcardInstance.setNIEMAnyPropertyValueNamespace('');
		}endif;	
	self.annotation.mapXSDAnnotation(result);
}
mapping 	XSD::XSDWildcard::XSDAttributeWildcard(umlContainer:UML::Element):UML::Property@pimUml
	inherits XSD::XSDWildcard::XSDWildcard
{
	init{}
		var targetStereotypeInstance:Stdlib::Element=result.ApplyStereotype(NIEMPropertyStereotype);
			targetStereotypeInstance.setNIEMPropertyKind('attribute');
}
mapping 	XSD::XSDNamedComponent::XSDNamedComponent(umlContainer:UML::Element):UML::NamedElement@pimUml
{
	init{}
	name:=if(self.name.oclIsUndefined())then self.aliasName else self.name endif;
}
mapping 	XSD::XSDRedefinableComponent::XSDRedefinableComponent(umlContainer:UML::Element):UML::NamedElement@pimUml
 	inherits XSD::XSDNamedComponent::XSDNamedComponent
{
	init{}
}

mapping 	XSD::XSDImport::XSDImport_init(umlContainer:UML::Element):UML::ElementImport@pimUml
 	inherits XSD::XSDSchemaDirective::XSDSchemaDirective
{
	init{
		if(self.resolvedSchema.oclIsUndefined())then{self.importSchema();}endif;
		result.importingNamespace:=self.schema.mapAbstractXSDSchema();

	}
}
mapping 	XSD::XSDImport::XSDImport(umlContainer:UML::Element):UML::ElementImport@pimUml
 	inherits XSD::XSDImport::XSDImport_init
 	when{self.isImportMapped()}
{
	init{
	}
//	log ('importing '+self.namespace+', from '+self.schemaLocation);
//	result.importingNamespace:=self.schema.mapAbstractXSDSchema();
	self.annotation.mapXSDAnnotation(result);
	////////////////////////////////////////
//	self.importSchema();
	// unresolved schemas will corrupt the elementImport
	assert error (not(self.resolvedSchema.oclIsUndefined())) with log('ERROR: failed to resolve schema at '+self.schemaLocation+' from schema '+self.schema.targetNamespace+' at '+self.schema.schemaLocation);
	
	importedElement:=self.resolvedSchema.mapAbstractXSDSchema();
}
mapping 	XSD::XSDInclude::XSDInclude(umlContainer:UML::Element):UML::PackageImport@pimUml
 	inherits XSD::XSDSchemaCompositor::XSDSchemaCompositor
// 	when{false}// suppress for now, we will need to handle targetNamespace, etc. for this case
{
	init{
//		result.importingNamespace:=self.schema.mapAbstractXSDSchema();
	}
	self.annotation.mapXSDAnnotation(result);
}
mapping 	XSD::XSDSchemaDirective::AbstractXSDSchemaDirective(umlContainer:UML::Element):UML::Element@pimUml
	disjuncts XSD::XSDInclude::XSDInclude,
		XSD::XSDImport::XSDImport,
		XSD::XSDRedefine::XSDRedefine
{}

mapping 	XSD::XSDSchemaDirective::XSDSchemaDirective(umlContainer:UML::Element):UML::Element@pimUml
{
	init{}
}

mapping 	XSD::XSDRedefine::XSDRedefine(umlContainer:UML::Element):UML::Package@pimUml
 	when{false}// suppress for now, we will need to handle targetNamespace, etc. for this case
{
	init{
		self.schema.mapAbstractXSDSchema().packagedElement+=result;

	}
	var packageImport:UML::PackageImport=new UML::PackageImport@pimUml();
	packageImport.importingNamespace:=result;
	packageImport.importedPackage:=self.resolvedSchema.mapAbstractXSDSchema();
	self.contents.mapAbstractXSDSchemaContent(result);
}
mapping 	XSD::XSDSchemaCompositor::XSDSchemaCompositor(umlContainer:UML::Element):UML::PackageImport@pimUml
 	inherits XSD::XSDSchemaDirective::XSDSchemaDirective
{
	init{
		result.importingNamespace:=self.schema.mapAbstractXSDSchema();

	}
	////////////////////////////////
	if(self.resolvedSchema.oclIsUndefined())then{
		log('ERROR: failed to resolve schema at '+self.schemaLocation+' from '+self.schema.targetNamespace+' at '+self.schema.schemaLocation);
	}else{
			var schemaIncluded:XSD::XSDSchema=self.resolvedSchema;
			/*
			if(schemaIncluded.targetNamespace.oclIsUndefined())then{
				// we still have a different schema when referenced via type?
				schemaIncluded.targetNamespace:=self.schema.targetNamespace;
			}endif;
			*/
			// if targetNamespace undefined or same as this schema, try to find a resolved schema via element types
			if(schemaIncluded.targetNamespace.oclIsUndefined() or (schemaIncluded.targetNamespace=self.schema.targetNamespace))then{
				var schemaRef:XSD::XSDSchema=self.schema.elementDeclarations.type.schema
//				->select(s|s.schemaLocation=schemaIncluded.schemaLocation)
				->select(s|(s.schemaLocation<>self.schema.schemaLocation) and (s.targetNamespace=self.schema.targetNamespace))
				->asSequence()->first();
				if(not(schemaRef.oclIsUndefined()))then{
					schemaIncluded:=schemaRef;		
					log('XSDCompositor replaced schemaInclude for '+schemaIncluded.targetNamespace+' at '+schemaIncluded.schemaLocation+' from '+self.schema.schemaLocation);			
				}endif;
			}endif;
			
			importedPackage:=schemaIncluded.mapAbstractXSDSchema();
		}endif;


}
mapping XSD::XSDModelGroup::XSDModelGroup(umlContainer:UML::Element):UML::Class@pimUml
{
	init{}
	// temporary owner is schema, caller should adjust owner
	self.schema.mapAbstractXSDSchema().packagedElement+=result;

	self.ModelGroup(result);
}

 mapping 	XSD::XSDElementDeclaration::XSDElementDeclaration(umlOwningClass:UML::Element):UML::Property@pimUml
 	inherits XSD::XSDFeature::XSDFeature
{
	init{}
// stereotype if nillable
	var targetStereotypeInstance:Stdlib::Element=result.ApplyStereotype(NIEMPropertyStereotype);
	targetStereotypeInstance.setNIEMPropertyNillable(self.resolvedElementDeclaration.nillable);
	targetStereotypeInstance.setNIEMPropertyKind('element');
	var resolvedElementDeclaration:XSD::XSDElementDeclaration=self.resolvedElementDeclaration;

	self.resolvedElementDeclaration.annotation.mapXSDAnnotation(result);
	if(not(self.elementDeclarationReference))then{
		// this is a top level element
		if(self.anonymousTypeDefinition.oclIsUndefined())then{
			// element does not have an anonymous type
			var typeDefinition:XSD::XSDTypeDefinition=self.typeDefinition;
			if(not((typeDefinition=null)or typeDefinition.oclIsUndefined()))then{
				// element is typed
				var umlType:UML::NamedElement=typeDefinition.resolveSchemaContentReference();
				if(((umlType=null)or umlType.oclIsUndefined())and typeDefinition.isRoleReference())then{
					// did not resolve type,  this is a NIEM-2 reference
					var referenceTarget:UML::Classifier=self.getPimReferenceTarget().oclAsType(UML::Classifier);
					if(not((referenceTarget=null)or referenceTarget.oclIsUndefined())and referenceTarget.oclIsKindOf(UML::Classifier))then{
						log('referenceTarget '+referenceTarget.name+', '+result.qualifiedName);
						umlType:=referenceTarget;
					}else{
						log('referenceTarget UNRESOLVED for '+result.qualifiedName);
					}endif;
				}endif;
				if(not((umlType=null)or umlType.oclIsUndefined())and umlType.oclIsKindOf(UML::Classifier))then{
					type:=umlType.oclAsType(UML::Classifier);
				}endif;
			}endif;
	
		}else{
			var umlOwningClassProxy:UML::Class=self.umlOwningClassProxy(result);
			type:=self.anonymousTypeDefinition.map AbstractXSDTypeDefinition(umlOwningClassProxy);
		}endif;
	}endif;
	self.identityConstraintDefinitions.map XSDIdentityConstraintDefinition(result);
	if(self.elementDeclarationReference)then{
		// this is a ref= element, pick up info from resolved element
		name:=resolvedElementDeclaration.name;
		// type, cardinality via particle, reference for eanother namespace
		var resolvedElement:UML::NamedElement=resolvedElementDeclaration.resolveSchemaContentReference();
		if(not((resolvedElement=null)or resolvedElement.oclIsUndefined()))then{
			// resolved top level UMLelement, see if it has type
	//		var umlType:UML::NamedElement=resolvedElementDeclaration.typeDefinition.resolveSchemaContentReference();
			var umlType:UML::NamedElement=resolvedElement.oclAsType(UML::Property).type;
			var typeDefinition:XSD::XSDTypeDefinition=resolvedElementDeclaration.typeDefinition;
			
			if(((umlType=null)or umlType.oclIsUndefined())and not((typeDefinition=null)or typeDefinition.oclIsUndefined()))then{
				// not able to resolve type at this time, check resolve directly		
					// the uml property type may not have been resolved at this point, resolve type via xsd element type
				umlType:=typeDefinition.resolveSchemaContentReference();
				if(((umlType=null)or umlType.oclIsUndefined()) and typeDefinition.isRoleReference())then{
					// allow niem 2 References,  
					var referenceTarget:UML::Classifier=resolvedElementDeclaration.getPimReferenceTarget().oclAsType(UML::Classifier);
						if(not((referenceTarget=null)or referenceTarget.oclIsUndefined())and referenceTarget.oclIsKindOf(UML::Classifier))then{
							log('referenceTarget2 '+referenceTarget.name+', '+result.qualifiedName);
							umlType:=referenceTarget;
						}else{
							log('referenceTarget2 UNRESOLVED for '+result.qualifiedName);
						}endif;
				}endif;
			}endif;
			if(not((umlType=null)or umlType.oclIsUndefined())and umlType.oclIsKindOf(UML::Classifier))then{
				type:=umlType.oclAsType(UML::Classifier);
			}endif;
			// reference if another schema, a subset cluster; suppress if ref to structures schema (for sequenceID)
			// just make the references anyway and clean up later
			resolvedElement.map PropertyReference(result);
		}endif;
		// and copy comments if none locally
		if(self.annotation.userInformation->isEmpty())then{
			resolvedElementDeclaration.annotation.mapXSDAnnotation(result);
		}endif;
		
	}endif;
	
	// no references in niem3; if niem2, need to pick up type
//	if(resolvedElementDeclaration.typeDefinition.isRoleReference())then{
	if(resolvedElementDeclaration.typeDefinition.isRoleReference() 
		
//		and ((result.type=null)or(result.type.oclIsUndefined()))
			
		)then{
		//aggregation:=UML::AggregationKind::none; // not in niem 3
		if(not((result.type=null)or result.type.oclIsUndefined())and  self.elementDeclarationReference)then{
			/*
		var referenceTarget:UML::Classifier=resolvedElementDeclaration.getPimReferenceTarget().oclAsType(UML::Classifier);
		if((result.type=null)or(result.type.oclIsUndefined()) 
			
			and not((referenceTarget=null)or referenceTarget.oclIsUndefined())
			and referenceTarget.oclIsKindOf(UML::Classifier)	
			)then{
					log('referenceTarget3 '+referenceTarget.qualifiedName);
		 type:=referenceTarget;
				}else{
					log('referenceTarget3 UNRESOLVED for '+result.qualifiedName);
				}endif;
		 
		 if(not((referenceTarget=null) or referenceTarget.oclIsUndefined())and referenceTarget.oclIsKindOf(UML::Classifier) and self.elementDeclarationReference)then{
		 	*/
		 	// make an association, this is an associationEnd other associationEnd owned by Association
		 	var association:UML::Association=new UML::Association@pimUml();
		 	result.getNearestPackage().packagedElement+=association;
		 	association.memberEnd+=result;
		 	var otherProperty:UML::Property=new UML::Property@pimUml();
		 	otherProperty.type:=result.owner.oclAsType(UML::Type);
		 	otherProperty.aggregation:=UML::AggregationKind::none;
			otherProperty.setLower(0);
			otherProperty.setUpper(-1);
			otherProperty.isDerived:=false;
			otherProperty.isReadOnly:=false;
			otherProperty.isOrdered:=false;
			otherProperty.isUnique:=false;
		 	association.ownedEnd+=otherProperty;
		 }endif;
	}else{
		
		// if type is not primitive, make an association, this is an associationEnd other associationEnd owned by Association
		if(not((result.type=null)or result.type.oclIsUndefined()) 
			and result.type.oclIsKindOf(UML::Class) 
			and self.elementDeclarationReference
		)then{
		 	var association:UML::Association=new UML::Association@pimUml();
		 	result.getNearestPackage().packagedElement+=association;
		 	association.memberEnd+=result;
		 	var otherProperty:UML::Property=new UML::Property@pimUml();
		 	otherProperty.type:=result.owner.oclAsType(UML::Type);
		 	otherProperty.aggregation:=UML::AggregationKind::none;
			otherProperty.setLower(0);
			otherProperty.setUpper(1);
			otherProperty.isDerived:=false;
			otherProperty.isReadOnly:=false;
			otherProperty.isOrdered:=false;
			otherProperty.isUnique:=false;
		 	association.ownedEnd+=otherProperty;
		}endif;
		
	}endif;
	
	
	if(resolvedElementDeclaration.isSubstitutionGroupHead())then{
		isDerivedUnion:=true;
		isDerived:=true;
		isReadOnly:=true;
	}endif;
	if(not(self.substitutionGroupAffiliation.oclIsUndefined()))then{
		var umlType:UML::NamedElement=self.substitutionGroupAffiliation.resolveSchemaContentReference();
		if(not(umlType.oclIsUndefined()))then{
			subsettedProperty+=umlType.oclAsType(UML::Property);
			self.reference(result,umlType,substitutionGroupAffiliationTag);// a transitory relation, will be remove later
		}endif;
	}endif;
}
// niem2
query XSD::XSDTypeDefinition::isRoleReference():Boolean=(self.name='ReferenceType') and (self.schema.targetNamespace.isStructuresSchemaNamespace());
// niem2
query XSD::XSDElementDeclaration::getPimReferenceTarget():UML::Type{
	// determine base
	self.annotation.getXSDAnnotationApplicationInformation().getElementElements()
		->select(i|i.isAppinfoReferenceTargetElement())->forEach(ref){
			var appliesToTypeXSD:XSD::XSDTypeDefinition=ref.referencedTypeDefinition(self);
			if(appliesToTypeXSD.oclIsUndefined())then{
				return null;
			}else{}endif;
			var type:UML::Type=appliesToTypeXSD.resolveSchemaContentReference().oclAsType(UML::Type);
			//log('getPimReferenceTarget '+appliesToTypeXSD.name+', '+type.qualifiedName);
			return type
	};
	return null;
}

query XSD::XSDElementDeclaration::isSubstitutionGroupHead():Boolean=
	 (self.typeDefinition.oclIsUndefined())
	or (self.typeDefinition.isAnyType())
	or self._abstract
	;

mapping UML::NamedElement::PropertyReference(clientFeature:UML::Property):UML::Realization@pimUml
	// do not hook up unless supplier is another schema or is a subset cluster 
	// suppress hookup if reference is to structures schema (for sequenceID)
{
	client+=clientFeature;	
	clientFeature.getNearestPackage().packagedElement+=result;
	supplier+=self;
	result.ApplyStereotype(NIEMReferencesStereotype);
}

mapping 	XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinition(umlContainer:UML::Element):UML::Class@pimUml
 	inherits XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinitionCommon
{
	init{}
	// owner established by XSDTypeDefinition, stereotype established by XSDComplexTypeDefinitionCommon
//	if(expandComplexContent)then{
		if(not(self.content.oclIsUndefined()))then{
			self.content.oclAsType(XSD::XSDParticle)->forEach(particle){
				particle.content.ParticleContent(result,particle);
			};
		}endif;
//	}else{log('defer expandComplexContent for '+self.schema.targetNamespace+' .. '+self.name);
//	}endif;
	self.attributeContents.attributeGroupContent(result,result);
	self.attributeWildcardContent.map XSDAttributeWildcard(result).name:='anyAttribute';
	self.syntheticWildcard.map XSDAttributeWildcard(result).name:='anyAttribute';
}

mapping 	XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinitionDataType(umlContainer:UML::Element):UML::DataType@pimUml
 	inherits XSD::XSDComplexTypeDefinition::XSDComplexTypeDefinitionCommon
 	when{not(self.content.oclIsUndefined()) and self.content.oclIsKindOf(XSD::XSDSimpleTypeDefinition)}
{
	init{}
	// owner established by XSDTypeDefinition, stereotype established by XSDComplexTypeDefinitionCommon
	// simpleType folded into same uml class
	var simpleTypeDefinition:XSD::XSDSimpleTypeDefinition=self.content.oclAsType(XSD::XSDSimpleTypeDefinition);
	//self.content.oclAsType(XSD::XSDSimpleTypeDefinition)->forEach(simpleTypeDefinition){
		simpleTypeDefinition.simpleTypeDefinitionContent(result,self);
		// baseTypeDefinition may not be resolved if the baseType is a simpleType
		/*
		if(self.baseTypeDefinition.oclIsUndefined())then{
				var umlGeneral:UML::NamedElement=simpleTypeDefinition.baseTypeDefinition.resolveSchemaContentReference();
				log('ComplexTypeSimpleContent backup base '+umlGeneral.qualifiedName);
				if(not(umlGeneral.oclIsUndefined()))then{
					self.map AbstractBaseTypeDefinition(umlGeneral.oclAsType(UML::Classifier),result);
					
				}endif;
		}endif;
		*/
		simpleTypeDefinition.annotation.mapXSDAnnotation(result);
		simpleTypeDefinition.derivationAnnotation.mapXSDAnnotation(result);
	//};
	var umlOwningClass:UML::Class=self.getSchemaFeatureClass(result);
	self.attributeContents.attributeGroupContent(result,umlOwningClass);
	self.attributeWildcardContent.map XSDAttributeWildcard(result).name:='anyAttribute';
	self.syntheticWildcard.map XSDAttributeWildcard(result).name:='anyAttribute';
		// TODO: facets
	
}
mapping 	XSD::XSDSimpleTypeDefinition::XSDSimpleTypeDefinition(umlContainer:UML::Element):UML::Classifier@pimUml
 	inherits XSD::XSDTypeDefinition::XSDTypeDefinition
{
	init{}
	// owner established by XSDTypeDefinition
	self.simpleTypeDefinitionContent(result,self);
}

//////////////////////////////////////////////////////////////////////////////////////constructors
constructor UML::Class::Class(className:String){
	name:=className;
}

constructor UML::Package::Package(className:String){
	name:=className;
}
constructor UML::Realization::Realization(className:String){
	name:=className;
}
constructor UML::Usage::Usage(className:String){
	name:=className;
}
///////////////////////queries
query XSD::XSDFeature::umlOwningClassProxy(umlProperty:UML::Property):UML::Class=
	umlProperty.owner.oclAsType(UML::Classifier)->switch(test){
		case(test.oclIsKindOf(UML::Class)) test.oclAsType(UML::Class);
		else self.getSchemaFeatureClass(umlProperty);
	}->asSequence()->first();
helper	XSD::XSDAttributeGroupContent::attributeGroupContent(inout umlClassifier:UML::Classifier,umlOwningClass:UML::Classifier){
	log('ERROR: unexpected AttributeGroupContent '+self.repr());
}
helper	XSD::XSDAttributeUse::attributeGroupContent(inout umlClassifier:UML::Classifier,umlOwningClass:UML::Classifier){
	var useProperty:UML::Property=self.content.mapAbstractXSDSchemaContent(umlClassifier).oclAsType(UML::Property);
	var literalString:UML::LiteralString=new UML::LiteralString@pimUml();
	literalString.name:=self.constraint.repr();
	literalString.value:=self.lexicalValue;
	useProperty.defaultValue:=literalString;
	useProperty.setLower(1);
	useProperty.setUpper(1);
	self.use->switch(use){
		case (use=XSD::XSDAttributeUseCategory::optional) useProperty.setLower(0);
		case (use=XSD::XSDAttributeUseCategory::required) 'doNothing';
		else {
			useProperty.setLower(0);
			useProperty.setUpper(0);
		};
	};
	return;
}
helper	XSD::XSDAttributeGroupDefinition::attributeGroupContent(inout umlClassifier:UML::Classifier,inout umlOwningClass:UML::Classifier){
		var umlSchema:UML::Package=self.resolvedAttributeGroupDefinition.schema.mapAbstractXSDSchema();
	//log('AttributeGroupDefinition resolved schema  '+umlSchema.qualifiedName);
	if(umlSchema.oclIsUndefined())then{return;}endif;
	var attributeGroupDefinitionProperty:UML::Property=new UML::Property@pimUml();
//	attributeGroupDefinitionProperty.name:=self.getComponentName();
	attributeGroupDefinitionProperty.name:=self.resolvedAttributeGroupDefinition.getComponentName();
	umlClassifier.setOwnedAttribute(attributeGroupDefinitionProperty);
	
	attributeGroupDefinitionProperty.aggregation:=UML::AggregationKind::shared;
				attributeGroupDefinitionProperty.setLower(0);
			attributeGroupDefinitionProperty.setUpper(1);
			attributeGroupDefinitionProperty.isDerived:=false;
			attributeGroupDefinitionProperty.isReadOnly:=false;
			attributeGroupDefinitionProperty.isOrdered:=false;
			attributeGroupDefinitionProperty.isUnique:=false;
			attributeGroupDefinitionProperty.visibility:=UML::VisibilityKind::public;
	
//if(true)then{log('TEST: suppress expansion of XSDAttributeGroupDefinition::attributeGroupContent '+self.repr()); }else{
		if(self.attributeGroupDefinitionReference)then{
			// type of property is resolved group
	
			attributeGroupDefinitionProperty.type:=
				self.resolvedAttributeGroupDefinition.mapAbstractXSDSchemaContent(umlSchema).oclAsType(UML::Classifier);
	
		}else{
			// create nested classifier and it becomes type of property
			var umlNestedClassifier:UML::Classifier=
				self.mapAbstractXSDSchemaContent(umlOwningClass).oclAsType(UML::Classifier);
			attributeGroupDefinitionProperty.type:=umlNestedClassifier;
		}endif;
//	}endif;
	//log('AttributeGroupDefinition property '+attributeGroupDefinitionProperty.qualifiedName);
}

query XSD::XSDConcreteComponent::getSchemaContentPackage():UML::Package{
	var umlSchema:UML::Package=self.schema.mapAbstractXSDSchema();

	var packageName:String=self.getSchemaContentPackageName();

	var schemaLevelPackage:UML::Package=umlSchema.nestedPackage->select(t|t.name=packageName)->asSequence()->first().oclAsType(UML::Package);
	if(schemaLevelPackage.oclIsUndefined())then{
		schemaLevelPackage:=new UML::Package@pimUml(packageName);
		umlSchema.packagedElement+=schemaLevelPackage;
		// we should apply stereotype now
	}endif;
	return schemaLevelPackage;

}
abstract query XSD::XSDConcreteComponent::getSchemaContentPackageName():String;
query XSD::XSDModelGroupDefinition::getSchemaContentPackageName():String=modelGroupDefinitionPackageName;
query XSD::XSDAttributeGroupDefinition::getSchemaContentPackageName():String=attributeGroupDefinitionPackageName;
query XSD::XSDConcreteComponent::getSchemaFeatureClass(umlProperty:UML::NamedElement):UML::Class{
	var umlSchema:UML::Package=umlProperty.getNearestPackage();
	var className:String=self.getSchemaFeatureClassName();
	return className.getSchemaLevelFeatureClass(umlSchema);
}
query XSD::XSDConcreteComponent::getSchemaFeatureClassName():String=elementDeclarationClassName;
query XSD::XSDElementDeclaration::getSchemaFeatureClassName():String=elementDeclarationClassName;
query XSD::XSDAttributeDeclaration::getSchemaFeatureClassName():String=attributeDeclarationClassName;

helper String::getSchemaLevelFeatureClass(inout umlSchema:UML::Package):UML::Class{
	var featureClass:UML::Class=umlSchema.packagedElement->select(t|t.name=self)->asSequence()->first().oclAsType(UML::Class);
	if(featureClass.oclIsUndefined())then{
		featureClass:=new UML::Class@pimUml(self);
		umlSchema.packagedElement+=featureClass;
		// we should apply stereotype now
		var featureStereotype:UML::Stereotype=NIEMPropertyHolderStereotype;
		var stereotypeInstance:Stdlib::Element=featureClass.ApplyStereotype(featureStereotype);
		
		
	}endif;
	return featureClass;
}

query XSD::XSDTypeDefinition::isAnyType():Boolean=self.name='anyType';
query XSD::XSDTypeDefinition::isAnySimpleType():Boolean=self.name='anySimpleType';

////////////////////////helpers
abstract helper XSD::XSDParticleContent::ParticleContent(inout umlClass:UML::Class,in particle:XSD::XSDParticle);
helper XSD::XSDElementDeclaration::ParticleContent(inout umlClass:UML::Class,in particle:XSD::XSDParticle){
			var attribute:UML::Property=self.mapAbstractXSDSchemaContent(umlClass).oclAsType(UML::Property);
	attribute.setLower(particle.minOccurs);
	attribute.setUpper(particle.maxOccurs);
}
helper XSD::XSDModelGroup::ParticleContent(inout umlClass:UML::Class,in particle:XSD::XSDParticle){
	// fold in
	self.ModelGroup(umlClass);
}
helper XSD::XSDModelGroupDefinition::ParticleContent(inout umlClass:UML::Class,in particle:XSD::XSDParticle){
	// fold in
	self.ModelGroupDefinition(umlClass);
}
helper XSD::XSDWildcard::ParticleContent(inout umlClass:UML::Class,in particle:XSD::XSDParticle){
	var attribute:UML::Property=self.map XSDWildcard(umlClass);
	attribute.name:='any';
	attribute.setLower(particle.minOccurs);
	attribute.setUpper(particle.maxOccurs);
}
helper XSD::XSDConcreteComponent::reference(inout umlOwner:UML::NamedElement,
	 in resolvedDeclarationReference:UML::NamedElement,referenceName:String):UML::Realization{
	 	if(resolvedDeclarationReference.oclIsUndefined())then{
	 		log('ERROR: reference supplier undefined for client '+umlOwner.qualifiedName);
	 	}endif;
		var declarationReference:UML::Realization=new UML::Realization@pimUml(referenceName);
		var umlPackage:UML::Package=umlOwner.getNearestPackage();
		umlPackage.packagedElement+=declarationReference;
		declarationReference.client+=umlOwner;
		declarationReference.supplier+=resolvedDeclarationReference;
		return declarationReference;
}
helper XSD::XSDConcreteComponent::unionMemberType(inout union:UML::NamedElement,
	 in memberType:UML::NamedElement,referenceName:String):UML::Usage{
	 	if(memberType.oclIsUndefined())then{
	 		log('ERROR: union member undefined for union '+union.qualifiedName);
	 	}endif;
//		var declarationReference:UML::Realization=new UML::Realization@pimUml(referenceName);
		var declarationReference:UML::Usage=new UML::Usage@pimUml(referenceName);
		var umlPackage:UML::Package=union.getNearestPackage();
		umlPackage.packagedElement+=declarationReference;
//		declarationReference.client+=memberType;
//		declarationReference.supplier+=union;
		declarationReference.supplier+=memberType;
		declarationReference.client+=union;
		declarationReference.applyStereotype(NIEMUnionOfStereotype);
		return declarationReference;
}
////////////////////////////////////////stereotypes
//////////////////////////////////end schemaContent
helper 	XSD::XSDSimpleTypeDefinition::simpleTypeDefinitionContent(inout umlClassifier:UML::Classifier,inout typeDefinition:XSD::XSDTypeDefinition)
{
	// if for some reason a complex typeDefinition did not resolve the baseType, then attempt via simpleType baseTypeDefinition
	if(typeDefinition.oclIsKindOf(XSD::XSDComplexTypeDefinition)and not(typeDefinition.baseType.oclIsUndefined()))then{}else{
		if(not(
			self.baseTypeDefinition.oclIsUndefined()
			or (self=self.baseTypeDefinition)
			or self.baseTypeDefinition.isAnyType()
	                or self.baseTypeDefinition.isAnySimpleType()
			or (umlClassifier.general->size()>0)
			))then{
			var umlGeneral:UML::NamedElement=self.baseTypeDefinition.resolveSchemaContentReference();
			if(not(umlGeneral.oclIsUndefined() or umlClassifier.general->includes(umlGeneral.oclAsType(UML::Classifier))))then{
				typeDefinition.map AbstractBaseTypeDefinition(umlGeneral.oclAsType(UML::Classifier),umlClassifier);
				
			}endif;
		}endif;
	}endif;

	var commonClass:UML::Class= self.getSchemaFeatureClass(umlClassifier);
	self.contents->forEach(content){
		// non-niem conformant embedded simpleTypeDefinition
		// if this were a class instead of datatype, then we could used nestedClassifier.
		// probably need to do this via properties now and move class up to a common place
		var contentClassifier:UML::Classifier= content.mapAbstractXSDSchemaContent(commonClass).oclAsType(UML::Classifier);
		switch{
			case(self.memberTypeDefinitions->includes(content)) {
					self.unionMemberType(umlClassifier,contentClassifier,'memberType');
				}
			case(self.itemTypeDefinition=content) {
				var itemTypeDefinition:UML::Property=new UML::Property@pimUml();
				itemTypeDefinition.name:='item';
				itemTypeDefinition.type:=contentClassifier;
				itemTypeDefinition.setLower(0);
				itemTypeDefinition.setUpper(-1);
				umlClassifier.setOwnedAttribute(itemTypeDefinition);
				
				}
			else {
				// otherwise a restriction to an anonymous SimpleType
				self.reference(umlClassifier,contentClassifier,'restriction');
			}
		};
	};

	self.memberTypeDefinitions->select(t|not(self.contents->includes(t)))->forEach(memberTypeDefinition){
		// a realization whose supplier is the union
		self.unionMemberType(umlClassifier,memberTypeDefinition.resolveSchemaContentReference(),'memberType');

	};
	if(not(self.itemTypeDefinition.oclIsUndefined() or self.contents->includes(self.itemTypeDefinition)))then{
		// add a property whose type is the content type, cardinality 0..*, name='item'
		var itemTypeDefinition:UML::Property=new UML::Property@pimUml();
		itemTypeDefinition.name:='item';
		itemTypeDefinition.type:=self.itemTypeDefinition.resolveSchemaContentReference().oclAsType(UML::Type);
		itemTypeDefinition.setLower(0);
		itemTypeDefinition.setUpper(-1);
		umlClassifier.setOwnedAttribute(itemTypeDefinition);
	}endif;
}
helper XSD::XSDModelGroup::ModelGroup(inout umlClass:UML::Class){
	self.annotation.mapXSDAnnotation(umlClass);
	self.contents->forEach(particle){particle.content.modelGroupParticleContent(umlClass,particle);};
	return;
}

helper XSD::XSDModelGroupDefinition::ModelGroupDefinition(inout umlClass:UML::Class){
	if(self.modelGroupDefinitionReference)then{
		var umlSchema:UML::Package=self.resolvedModelGroupDefinition.schema.mapAbstractXSDSchema();
		// is this necessary?
		self.reference(umlClass,
			self.resolvedModelGroupDefinition.mapAbstractXSDSchemaContent(umlSchema).oclAsType(UML::NamedElement),'ref');
	}endif;
	if(not(self.modelGroup.oclIsUndefined()))then{
		self.modelGroup.ModelGroup(umlClass);
	}endif;
}
abstract helper XSD::XSDParticleContent::modelGroupParticleContent(inout umlClass:UML::Class,in particle:XSD::XSDParticle);

helper XSD::XSDElementDeclaration::modelGroupParticleContent(inout umlClass:UML::Class,in particle:XSD::XSDParticle){
	var attribute:UML::Property=self.mapAbstractXSDSchemaContent(umlClass).oclAsType(UML::Property);
	attribute.setLower(particle.minOccurs);
	attribute.setUpper(particle.maxOccurs);
}
helper XSD::XSDWildcard::modelGroupParticleContent(inout umlClass:UML::Class,in particle:XSD::XSDParticle){
	var attribute:UML::Property=self.map XSDWildcard(umlClass);
	attribute.name:='any';
	attribute.setLower(particle.minOccurs);
	attribute.setUpper(particle.maxOccurs);
}
helper XSD::XSDModelGroup::modelGroupParticleContent(inout umlClass:UML::Class,in particle:XSD::XSDParticle){
	var modelGroup:UML::Class=self.map XSDModelGroup(umlClass);
	// as nestedClassifier
	var index:Integer=particle.container.oclAsType(XSD::XSDModelGroup).particles->indexOf(particle);
	var modelGroupName:String=self.compositor.repr()+'_'+(index.repr());
	umlClass.nestedClassifier+=modelGroup;
	modelGroup.name:=modelGroupName;
	modelGroup.ApplyStereotype(NIEMChoiceStereotype);
	// and type of a property
	var attribute:UML::Property=new UML::Property@pimUml();
	attribute.type:=modelGroup;
	attribute.name:=umlClass.name+'_'+modelGroupName;
	attribute.setLower(particle.minOccurs);
	attribute.setUpper(particle.maxOccurs);
	umlClass.ownedAttribute+=attribute;
	return;
}
helper XSD::XSDModelGroupDefinition::modelGroupParticleContent(inout umlClass:UML::Class,in particle:XSD::XSDParticle){
	// fold in
	self.ModelGroupDefinition(umlClass);
//	var modelGroupDefinition:UML::Class=self.mapAbstractXSDSchemaContent(umlClass).oclAsType(UML::Class);
	var modelGroupDefinition:UML::Class=null;
	if(self.modelGroupDefinitionReference)then{
		var umlSchema:UML::Package=self.resolvedModelGroupDefinition.schema.mapAbstractXSDSchema();
		modelGroupDefinition:=self.resolvedModelGroupDefinition.mapAbstractXSDSchemaContent(umlSchema).oclAsType(UML::Class);
	}else{
		modelGroupDefinition:=self.mapAbstractXSDSchemaContent(umlClass).oclAsType(UML::Class);
	}endif;
	
	// as nestedClassifier
	// and type of a property
	var attribute:UML::Property=new UML::Property@pimUml();
	attribute.type:=modelGroupDefinition;
	if(modelGroupDefinition.name.oclIsUndefined())then{
	attribute.name:='modelGroupDefinition';
	}else{
		attribute.name:=modelGroupDefinition.name;
	}endif;
	attribute.setLower(particle.minOccurs);
	attribute.setUpper(particle.maxOccurs);
	umlClass.ownedAttribute+=attribute;
	return;
}
helper UML::Classifier::setOwnedAttribute(umlProperty:UML::Property){
	log('setOwnedAttribute.Classifier ERROR UNEXPECTED CALL '+self.qualifiedName);
}
helper UML::Class::setOwnedAttribute(umlProperty:UML::Property){
	var umlClassifier:UML::Class=self;
	umlClassifier.ownedAttribute+=umlProperty;
	return;
}
helper UML::DataType::setOwnedAttribute(umlProperty:UML::Property){
	var umlClassifier:UML::DataType=self;
	umlClassifier.ownedAttribute+=umlProperty;
	return;
}

///////////////////////////////abstract	platform bindings
/////////// temporary
query XSD::XSDNamedComponent::getComponentName():String{
	if(self.name.oclIsUndefined())then{return self.aliasName;}else{}endif;
	return self.name;
}

////////DO NOT REMOVE, these are now resident in super since sub does not override properly; these to be documented as abstract
// niem2
query OclAny::isAppinfoReferenceTargetElement():Boolean=self.isAppinfoElement() and (self.getElementName()='ReferenceTarget');
// NIEM2
query OclAny::isAppinfoElement():Boolean=self.getElementNamespace().isAppinfoNamespace();
query OclAny::referencedTypeDefinition(context:XSD::XSDConcreteComponent):XSD::XSDTypeDefinition{
	//log('referencedTypeDefinition '+self.getAppInfoName()+', '+self.getAppInfoNamespace());
	// self is a DOM Element
	return
	self.referencedSchemas(context).contents->select(s|s.oclIsKindOf(XSD::XSDTypeDefinition) and
		(s.oclAsType(XSD::XSDTypeDefinition).name=self.getAppInfoName())
		).oclAsType(XSD::XSDTypeDefinition)
	->asSequence()->first();
	}
query OclAny::referencedSchemas(context:XSD::XSDConcreteComponent):Set(XSD::XSDSchema){
	var appInfoNamespace:String=self.getAppInfoNamespace();
	if(appInfoNamespace.oclIsUndefined())then{
		return Set{context.schema};
	}endif;
	// make sure imported schemas have been resolved
	context.schema.contents
			->select(c|c.oclIsKindOf(XSD::XSDImport)).oclAsType(XSD::XSDImport)
			->forEach(schemaImport){
				if(schemaImport.resolvedSchema.oclIsUndefined())then{schemaImport.importSchema();}endif;
			};
		var resolvedSchemas:Sequence(XSD::XSDSchema)=context.schema.contents
			->select(c|c.oclIsKindOf(XSD::XSDSchemaDirective)).oclAsType(XSD::XSDSchemaDirective).resolvedSchema;
		var referencedSchemas:Set(XSD::XSDSchema)=resolvedSchemas
			->union(Sequence{context.schema})
//			->select(s|s.targetNamespace.isAppinfoNamespace())
			->select(s|s.targetNamespace=appInfoNamespace)
			->asSet();
		if(referencedSchemas->isEmpty())then{
			log("ERROR: no schemas found for "+appInfoNamespace+', resolvedSchema count='+resolvedSchemas->size().repr()+' from '+context.schema.targetNamespace+' at location '+context.schema.schemaLocation);
		}	else{}endif;
		return referencedSchemas;
}
query XSD::XSDSchema::isMapped():Boolean{
	var targetNamespace=self.targetNamespace;
	if((targetNamespace=schemaForSchemaNamespace)
	or (targetNamespace.isStructuresSchemaNamespace())
	or (targetNamespace.isAppinfoNamespace())
	or (targetNamespace=ConformanceTargetNamespace)
	or (targetNamespace=LocalTerminologyTargetNamespace)
	
	//or (targetNamespace=appinfo2SchemaNamespace) // no longer exists
	or (targetNamespace.isProxySchemaNamespace()))then {return false;}endif;
	return true;
}
query XSD::XSDImport::isImportMapped():Boolean{
	var targetNamespace=self.namespace;
	if((targetNamespace=schemaForSchemaNamespace)
	or (targetNamespace.isStructuresSchemaNamespace())
	or (targetNamespace.isAppinfoNamespace())
	or (targetNamespace=ConformanceTargetNamespace)
	or (targetNamespace=LocalTerminologyTargetNamespace)
	//or (targetNamespace=appinfo2SchemaNamespace) // no longer exists
	or (targetNamespace.isProxySchemaNamespace()))then {return false;}endif;
	if(self.resolvedSchema.mapAbstractXSDSchema().oclIsUndefined())then{return false;}endif;
	return true;
}
helper UML::Package::applyProfile(profile : UML::Profile){
	var profileApplication: UML::ProfileApplication=new UML::ProfileApplication@pimUml();
	profileApplication.applyingPackage:=self;
	profileApplication.appliedProfile:=profile;
	return;
}

 


query String::toRelativeMdpLocation():String{
	var location:String=self;
	if(location.startsWith('./'))then {location:=location.substringAfter('./');} else {} endif;
	if(location.endsWith('/'))then {location:=location.substring(1,location.size()-1);} else {} endif;
	return location;
};
query String::toBaseName():String{
	var index:Integer=self.rfind('/');
	if(index>0)then{return self.substring(index+1,self.size());}else{}endif;
	return self;
};

helper String::getOwnerPackage(inout topPackage:UML::Package):UML::Package{
	var topPackageName:String=self.substringBefore('/');
	if(topPackageName.oclIsUndefined())then{return topPackage;}
	else{}endif;
	topPackage.nestedPackage->select(p|p.name=topPackageName)->forEach(existingPackage){
		return self.substringAfter('/').getOwnerPackage(existingPackage);
	};
	var newPackage:UML::Package=new UML::Package@pimUml();
	newPackage.name:=topPackageName;
	topPackage.packagedElement+=newPackage;
	return self.substringAfter('/').getOwnerPackage(newPackage);
}
abstract query XSD::XSDTypeDefinition::isEnumeration():Boolean;
query XSD::XSDComplexTypeDefinition::isEnumeration():Boolean=
	not(self.baseTypeDefinition.oclIsUndefined()) 
	and (self.baseTypeDefinition<>self) 
	and self.baseTypeDefinition.isEnumeration();
query XSD::XSDSimpleTypeDefinition::isEnumeration():Boolean{
	if(self.enumerationFacets->notEmpty())then{return true;}endif;
	if(self.name.endsWith('CodeType') or self.name.endsWith('CodeSimpleType'))then{return true;}endif;
	if(self.baseTypeDefinition.oclIsUndefined()or (self.baseTypeDefinition=self))then{return false;}endif;
	return self.baseTypeDefinition.isEnumeration();
}	
abstract query XSD::XSDTypeDefinition::isPrimitiveType():Boolean;
query XSD::XSDSimpleTypeDefinition::isPrimitiveType():Boolean=true;
query XSD::XSDComplexTypeDefinition::isPrimitiveType():Boolean=
//	(
	not(self.baseTypeDefinition.oclIsUndefined())
	and (self.baseTypeDefinition<>self) 
	and self.baseTypeDefinition.isPrimitiveType()
//	)or (self.content.oclIsKindOf(XSD::XSDSimpleTypeDefinition))
	;

/////////////////////////////////////////////////////

helper UML::Package::removeEmptyPackages(){
	self.nestedPackage.removeEmptyPackages();
	if(self.packagedElement->isEmpty())then 
		self.removeElement() 
//        pimUml.removeElement(self)
	endif;
}

///////////platform-specific MPD catalog 
abstract helper 		gatherCatalogedSchemas(mpdRootPackage:UML::Package);